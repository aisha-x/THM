# TryHackMe: Dissecting PE Headers room summary


Room Link: https://tryhackme.com/room/dissectingpeheaders

Other resources: https://learn.microsoft.com/en-us/windows/win32/debug/pe-format

- Note: Portions of this content were copied from a TryHackMe room; the remaining parts were summarized.

# **Task 1: Introduction**

Executable files in Windows use the **.exe** extension and follow the **Portable Executable (PE)** format — a standardized structure based on the **COFF (Common Object File Format)**. The PE format is essential for understanding how Windows programs and malware operate.

In this room, you’ll learn how to:

- Understand and interpret different PE headers
- Read PE header data using analysis tools
- Identify packed executables
- Use PE header information for malware analysis

# **Task 2: Overview of PE Headers**

A PE file is simply binary data represented in hexadecimal form, which Windows interprets as executable instructions. To make sense of this data, we use tools like **wxHexEditor** and **pe-tree**.

The **pe-tree** utility visualizes the internal structure of PE files through expandable menus representing various headers. Key headers include:

- `IMAGE_DOS_HEADER`
- `IMAGE_NT_HEADERS`
- `FILE_HEADER`
- `OPTIONAL_HEADER`
- `IMAGE_SECTION_HEADER`
- `IMAGE_IMPORT_DESCRIPTOR`

Each of these headers is a **structure (struct)** that stores specific information about the executable. Understanding their layout helps analysts interpret PE files even without relying on one specific tool.

# **Task 3: IMAGE_DOS_HEADER and DOS_STUB**

The **IMAGE_DOS_HEADER** is the first 64 bytes of a PE file.

<img width="1678" height="811" alt="image" src="https://github.com/user-attachments/assets/d9e14a3f-8fed-49f7-bbb7-ce5138af5692" />

- The first two bytes, `4D 5A` (ASCII “MZ”), identify the file as a **Portable Executable** — the initials of **Mark Zbikowski**, a Microsoft engineer.
- The last field, **`e_lfanew`**, points to the location of the **IMAGE_NT_HEADERS**, marking where the main PE header starts.
- These values are stored in **little-endian format** (common in x86 systems).

The **DOS_STUB** follows the DOS header. It contains a simple message —

> “This program cannot be run in DOS mode.”
> 
> 
> This message appears if the executable is run in an environment that doesn’t support PE files, such as MS-DOS.
> 

While these two sections mainly exist for **backward compatibility**, they’re useful in analysis for identifying the file type and understanding how Windows locates the rest of the PE structure.

# Task 4: IMAGE_NT_HEADERS

We can find details of IMAGE_NT_HEADERS in [Microsoft Documentation](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32).

**NT_HEADERS:**

Before diving into the details of NT_HEADERS, let's get an overview of the NT_HEADERS. The NT_HEADERS consist of the following:

- Signature
- FILE_HEADER
- OPTIONAL_HEADER

We will cover the Signature and FILE_HEADER in this task but the OPTIONAL_HEADER in the next task.

<img width="980" height="445" alt="image" src="https://github.com/user-attachments/assets/c3239944-289e-4f81-b94e-58921582bccf" />

The starting address of IMAGE_NT_HEADERS is found in `e_lfanew` from the IMAGE_DOS_HEADER. In the `zmsuz3pinwl`binary, we saw that this address was `0x000000f8`. So let's start by going to this offset and see what we find there. We can do that by pressing `Ctrl+G` in the Hex Editor Window or going to Edit>Go to offset from the GUI.

<img width="551" height="167" alt="image" src="https://github.com/user-attachments/assets/5a2e29e4-7c8a-41c6-b178-bac0cbf246aa" />

We have to make sure that we select `From beginning` in `Type of branch` option at the bottom and the data type is set to `Hex` for correct results.

### **Signature:**

The first 4 bytes of the NT_HEADERS consist of the Signature. We can see this as the bytes `50 45 00 00` in Hex, or the characters `PE` in ASCII as shown in the Hex editor.

<img width="1120" height="358" alt="image" src="https://github.com/user-attachments/assets/71d0b8b1-eb0d-4a0e-ad65-21bd99cdf601" />

The Signature denotes the start of the NT_HEADER. Apart from the Signature, the NT_HEADER contains the FILE_HEADER and the IMAGE_OPTIONAL_HEADER.

**FILE_HEADER:**

The FILE_HEADER contains some vital information. The following screenshot shows the FILE_HEADER as shown in the pe-tree utility.

<img width="1181" height="555" alt="image" src="https://github.com/user-attachments/assets/20b5290c-e74e-49f0-bf19-f6c028d599c3" />

As we can see in the above screenshot, the FILE_HEADER has the following fields:

- `Machine`This field mentions the type of architecture for which the PE file is written. In the above example, we can see that the architecture is i386 which means that this PE file is compatible with 32-bit Intel architecture.
- `NumberOfSections`A PE file contains different sections where code, variables, and other resources are stored. This field of the IMAGE_FILE_HEADER mentions the number of sections the PE file has. In our case, the PE file has seven sections.
- `TimeDateStamp`This field contains the time and date of the binary compilation.
- `PointerToSymbolTable and NumberOfSymbols` These fields are not generally related to PE files. Instead, they are here due to the COFF file headers.
- `SizeOfOptionalHeader`This field contains the size of the optional header, which we will learn about in the next task. In our case, the size is 224 bytes.
- `Characteristics`*:* This is another critical field. This field mentions the different characteristics of a PE file. In our case, this field tells us that the PE file has *stripped relocation* information, line numbers, and local symbol information. It is an executable image and compatible with a 32-bit machine. This member can be one or more of the following values.
    
    
    | Value | Meaning |
    | --- | --- |
    | **IMAGE_FILE_RELOCS_STRIPPED**0x0001 | Relocation information was stripped from the file. The file must be loaded at its preferred base address. If the base address is not available, the loader reports an error. |
    | **IMAGE_FILE_EXECUTABLE_IMAGE**0x0002 | The file is executable (there are no unresolved external references). |
    | **IMAGE_FILE_LINE_NUMS_STRIPPED**0x0004 | COFF line numbers were stripped from the file. |
    | **IMAGE_FILE_LOCAL_SYMS_STRIPPED**0x0008 | COFF symbol table entries were stripped from file. |
    | **IMAGE_FILE_AGGRESIVE_WS_TRIM**0x0010 | Aggressively trim the working set. This value is obsolete. |
    | **IMAGE_FILE_LARGE_ADDRESS_AWARE**0x0020 | The application can handle addresses larger than 2 GB. |
    | **IMAGE_FILE_BYTES_REVERSED_LO**0x0080 | The bytes of the word are reversed. This flag is obsolete. |
    | **IMAGE_FILE_32BIT_MACHINE**0x0100 | The computer supports 32-bit words. |
    | **IMAGE_FILE_DEBUG_STRIPPED**0x0200 | Debugging information was removed and stored separately in another file. |
    | **IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP**0x0400 | If the image is on removable media, copy it to and run it from the swap file. |
    | **IMAGE_FILE_NET_RUN_FROM_SWAP**0x0800 | If the image is on the network, copy it to and run it from the swap file. |
    | **IMAGE_FILE_SYSTEM**0x1000 | The image is a system file. |
    | **IMAGE_FILE_DLL**0x2000 | The image is a DLL file. While it is an executable file, it cannot be run directly. |
    | **IMAGE_FILE_UP_SYSTEM_ONLY**0x4000 | The file should be run only on a uniprocessor computer. |
    | **IMAGE_FILE_BYTES_REVERSED_HI**0x8000 | The bytes of the word are reversed. This flag is obsolete. |

*Source: Microsoft Documentation*

While we looked at the FILE_HEADER using the pe-tree utility, we can see that the hex values for each field are also shown in the pe-tree utility. Can you look at the Hex editor and find where each value is located?

<img width="1362" height="167" alt="image" src="https://github.com/user-attachments/assets/3cf6ac31-1d4a-4974-a251-c4918af73bfe" />

To learn more about the FILE_HEADER, you can check out [Microsoft Documentation](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header) for it. 

# Task 5: OPTIONAL_HEADER

The OPTIONAL_HEADER is also a part of the NT_HEADERS. It contains some of the most important information present in the PE headers. Let's see what it looks like in the pe-tree utility.

<img width="989" height="674" alt="image" src="https://github.com/user-attachments/assets/934c64a4-1279-40aa-99d0-8effc5b04e2c" />

The stating of the OPTINAL_HEADER

<img width="765" height="247" alt="image" src="https://github.com/user-attachments/assets/8e81f585-c389-4c1d-a059-505e742ceee3" />

Let's learn about some of the critical fields in the OPTIONAL_HEADER.

- `Magic` The Magic number tells whether the PE file is a 32-bit or 64-bit application. If the value is 0x010B, it denotes a 32-bit application; if the value is 0x020B, it represents a 64-bit application. The above screenshot of the Hex Editor highlights the bytes that reveal the magic of the loaded PE file. Since the value is 0x010B, it shows that it is a 32-bit application.
- `AddressOfEntryPoint`This field is significant from a malware analysis/reverse-engineering point of view. **This is the address from where Windows will begin execution.** In other words, the first instruction to be executed is present at this address. This is a Relative Virtual Address (RVA), meaning it is at an offset relative to the base address of the image (ImageBase) once loaded into memory.
- `BaseOfCode and BaseOfData`These are the addresses of the code and data sections, respectively, relative to ImageBase.
- `ImageBase`The ImageBase is the preferred loading address of the PE file in memory. Generally, the ImageBase for `.exe`files is 0x00400000, which is also the case for our PE file. Since Windows can't load all PE files at this preferred address, some relocations are in order when the file is loaded in memory. These relocations are then performed relative to the ImageBase.
- `Subsystem`This represents the Subsystem required to run the image. The Subsystem can be Windows Native, GUI (Graphical User Interface), CUI (Commandline User Interface), or some other Subsystem. The screenshot above from the pe-tree utility shows that the Subsystem is 0x0003, representing Windows GUI Subsystem. We can find the complete list in [Microsoft Documentation](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32#:~:text=critical%20system%20process.-,Subsystem,-The%20subsystem%20required).
- `DataDirectory`The DataDirectory is a structure that contains import and export information of the PE file (called Import Address Table and Export Address Table). This information is handy as it gives a glimpse of what the PE file might be trying to do. We will expand on the import information later in this room.

Although there is more information in the OPTIONAL_HEADER, we will not cover it in this room. If you want to learn more about the OPTIONAL_HEADER, you can check out [Microsoft Documentation](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32) about this header.

# Task 6: IMAGE_SECTION_HEADER

The **`name`**field in the IMAGE_SECTION_HEADER struct is exactly **8 bytes** (`IMAGE_SIZEOF_SHORT_NAME = 8`) allocated. Here, the `zmsuz3pinwl`has 7 sections, three of which are properly named (within the 8-character limit)

<img width="1000" height="619" alt="image" src="https://github.com/user-attachments/assets/32526e5e-c36e-4435-81b7-77d6b58624a5" />

As for the other 4 sections, they might be:

- Named with nonprintable bytes or all zeros (i.e. no meaningful name).
- Obfuscated or stripped by a packer or post-build tool.
- Dummy or padding sections inserted by the tool or compiler that didn’t bother naming them.

**The commonly found sections in a PE file.**

- `text`The .text section is generally the section that contains executable code for the application.
- `.data`This section contains initialized data of the application. It has READ/WRITE and EXECUTE permissions.
    
    <img width="982" height="366" alt="image" src="https://github.com/user-attachments/assets/762c5682-4cd6-49de-b18b-90fad9aeeacc" />

- `.*rdata/.idata*`These sections often contain the import information of the PE file. Import information helps a PE file import functions from other files or Windows API.
- `.ndata`The .ndata section contains uninitialized data.
- `.reloc`This section contains relocation information of the PE file.
- `.rsrc` The resource section contains icons, images, or other resources required for the application UI.
    
    <img width="1003" height="403" alt="image" src="https://github.com/user-attachments/assets/c64054be-157b-442a-8bba-7b143d49fd3c" />

    

**The important information these sections include:** 

- `VirtualAddress`This field indicates this section's Relative Virtual Address (RVA) in the memory.
- `VirtualSize`This field indicates the section's size once loaded into the memory.
- `SizeOfRawData`This field represents the section size as stored on the disk before the PE file is loaded in memory.
- `Characteristics`The characteristics field tells us the permissions that the section has. For example, if the section has READ permissions, WRITE permissions or EXECUTE permissions.

For more information, see [Microsoft Documentation](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header)

# Task 7: IMAGE_IMPORT_DESCRIPTOR

This is `zmsuz3pinwl` PE

<img width="1185" height="641" alt="image" src="https://github.com/user-attachments/assets/a3146e12-d3ae-422c-8d52-b418a74e1714" />

And this is `redline`PE 

<img width="1044" height="793" alt="image" src="https://github.com/user-attachments/assets/3a5be46a-099f-4695-87bf-dbdaa1d774ce" />

- PE executables rely on **Windows API DLLs** (like `KERNEL32.dll`, `ADVAPI32.dll`, `SHELL32.dll`, `OLE32.dll`, `USER32.dll`) to perform many runtime functions; the PE file doesn’t contain all code itself.
- The **`IMAGE_IMPORT_DESCRIPTOR`** lists which DLLs and which exported functions the PE will import when run. Inspecting these imports gives quick clues about intended behavior (e.g., `RegCreateKeyExW` → registry changes; `CreateProcessW` → spawning processes; `CreateDirectoryW` → creating folders; `WriteFile` → writing files).
- The descriptor includes fields like **`OriginalFirstThunk`** and **`FirstThunk`** that the OS uses to build the **Import Address Table (IAT)** at load time (the IAT holds the actual runtime addresses for the imported functions).
- For details about a specific API, consult Microsoft documentation for that function (e.g., `RegCreateKeyExW` [docs](https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexw) explain exactly what the API does and parameters it accepts).
- **Practical takeaway:** Import analysis is a fast, useful static heuristic for triage and behavioral inference, but it’s not definitive (imports may be unused, resolved dynamically, or obfuscated). Combine import inspection with dynamic analysis, strings, and section/entropy checks for stronger conclusions

# Task 8: Packing and Identifying packed executables

Packers are tools used to obfuscate the contents of a PE file, making it difficult to analyze or reverse-engineer. They wrap the original code in a layer of compression or encryption, preventing static analysis tools like hex editors or PE viewers from reading the real data. When executed, the packed file first unpacks itself in memory before running the original code. While legitimate developers use packing to prevent piracy, malware authors often use it to evade detection.

**Here is a list to check for packed executable using `pecheck`and `pe-tree` tools** 

### 1) Unconventional / missing section names

**Why it points to packing:** packers often rename, remove, or zero-out section names to confuse analysts or avoid signature detection. They may also create many short random-looking names (or leave the 8-byte name field null).

<img width="1150" height="730" alt="image" src="https://github.com/user-attachments/assets/887435c7-4fd0-458d-a7db-143519a1aa1e" />

### 2) EXECUTE permissions on multiple sections (IMAGE_SCN_MEM_EXECUTE)

**Why it points to packing:** normal PE layout usually has only `.text` (code) marked executable. Packers often decompress/stub code into writable/executable sections (or mark several sections R/X/W) to host the unpacker and the payload. Multiple exec sections suggest code is placed in non-standard locations.

**What to look for in pe-tree:** check the **Characteristics/Flags** column for each section (look for `EXECUTE` or the flag mask `IMAGE_SCN_MEM_EXECUTE`). If you see `EXECUTE` on `.rsrc`, `.data`, or many unnamed sections, that’s suspicious.

<img width="1474" height="318" alt="image" src="https://github.com/user-attachments/assets/8364ddf5-3f7a-443a-8838-bf2f4e1d6b92" />

All seven sectionss have these permissions → INITIALIZED_DATA | EXECUTE | READ | WRITE

### 3) High entropy (approaching 8.0) for some sections

**Why it points to packing:** entropy measures randomness. Compressed or encrypted data has high entropy near 8.0 (maximum for byte distribution). Normal code/data has lower entropy (code has structure; resources less random). If you find sections with entropy > ~7.0–7.5, they are likely compressed or encrypted — typical for packed payloads.

**What to look for in pe-tree:** many PE viewers show **Section Entropy**; inspect each section’s entropy value.

**Rule of thumb thresholds:**

- < 6.5 — likely normal code/data.
- 6.5–7.5 — suspicious/possible compression.
- 7.5 — strong indicator of compression/encryption/packing.
    
    <img width="1292" height="353" alt="image" src="https://github.com/user-attachments/assets/bb136294-c7a3-456f-ae08-f081b86d9e94" />

    

The first three unnamed sections and the .data section have a higher entropy.

### 4) Large difference between `SizeOfRawData` and `Misc.VirtualSize` (VirtualSize)

**Why it points to packing:** 

- **`SizeOfRawData`** → how many bytes are stored on disk.
- **`Misc.VirtualSize` (or `VirtualSize`)** → how much space that section *occupies in memory* when loaded.

When the file is executed, Windows **loads each section into memory** and expands it to the size specified by `VirtualSize`. Normally, for **regular PE files (non-packed)**:

`VirtualSize` ≈ `SizeOfRawData`, maybe differing by a few hundred bytes due to alignment. But for **packed executables**, the packed section on disk is *compressed*, so its raw size is small, while the virtual size (after unpacking in memory) is huge.

**Overall pattern and conclusion**

| Section | Virtual Size vs Raw | Suspicious? | Why |
| --- | --- | --- | --- |
| 0 | 4 MB vs 845 KB | ✅ High | Compressed/encrypted payload |
| 1 | Small diff | ❌ Normal | — |
| 2 | Small diff | ⚠️ Slight | Tiny stub possibly |
| 3 (.rsrc) | 76 KB vs 1 KB | ✅ High | Compressed/encrypted resources |
| 4 | 4 KB vs 0 | ✅ High | Memory-only section (unpacked code) |
| 5 (.data) | Similar | ❌ Normal | Regular data section |
| 6 (.adata) | 4 KB vs 0 | ✅ High | Memory-only allocation section |

### 5) Very few import functions (sparse `IMAGE_IMPORT_DESCRIPTOR`)

**Why it points to packing:** a typical application imports many Windows APIs (*compared with the redline PE we analyzed in the last task*). Packers often use a tiny loader stub that resolves imports dynamically at runtime (e.g., by calling `GetProcAddress` on `LoadLibrary` results or walking PE structures) rather than listing dozens of API names in the IAT. That keeps the Import Table minimal (or empty) and hides the real import list until runtime.

**What to look for in pe-tree:** open the **Imports**/IAT view. If the IAT is tiny (few DLLs or few functions) while the program is expected to do many OS calls, that’s suspicious. Also, check for references to just `LoadLibrary`/`GetProcAddress` or `VirtualAlloc`/`VirtualProtect` (common loader functions).

<img width="922" height="241" alt="image" src="https://github.com/user-attachments/assets/ca11b5f4-7673-4ea7-a975-ac2c5e0c9ef3" />
