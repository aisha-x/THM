# TryHackMe: Windows API

Room URL: https://tryhackme.com/room/windowsapi

> Note: Part of this summary are based on the TryHackMe content, while other sections include external explanation

# Task-1: Introduction

The Windows API provides native functionality to interact with key components of the Windows operating system. The API is widely used by many, including red teamers, threat actors, blue teamers, software developers, and solution providers.

The API can integrate seamlessly with the Windows system, offering its range of use cases. You may see the Win32 API being used for offensive tool and malware development, **EDR** (**E**ndpoint **D**etection & **R**esponse) engineering, and general software applications. For more information about all of the use cases for the API, check out the [Windows API Index](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list).

### Learning Objectives

1. Understand what the Windows API is, its use cases, and how it interacts with the OS subsystems
2. Learn how to implement the Windows API in different languages
3. Understand how the Windows API can be used from a malicious perspective and break down several practical case studies

Before beginning this room, we recommend general familiarity with operating system architecture. Basic programming knowledge is also recommended but not required.

This room aims to teach the Windows API at a fundamental level. We will briefly cover implementations of the Win32 API, but we will focus on why and where API calls are used.

# Task-2: Subsystem and Hardware Interaction

## User Mode vs Kernel Mode on Windows

### What they are

- In Windows (and many other OSes), the CPU and OS differentiate between two major privilege levels: *user mode* and *kernel mode*. [learn.microsoft.com+2techtarget.com+2](https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode)
- **User mode**: The mode in which “normal” applications run. They have restricted privileges: they cannot directly access hardware or arbitrary memory. [techtarget.com+2Super User+2](https://www.techtarget.com/searchsoftwarequality/tip/User-mode-vs-kernel-mode-OSes-explained)
- **Kernel mode**: The mode in which the core OS components, device drivers, hardware abstraction layer, etc., run. Code here has full access to system resources, memory, hardware, etc. [Wikipedia+1](https://en.wikipedia.org/wiki/Architecture_of_Windows_NT)

### Why have the distinction

- *Stability*: If an application in user mode crashes, it ideally only takes itself out, not the whole OS. [learn.microsoft.com+1](https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode)
- *Security*: Prevents untrusted or buggy code from doing arbitrary hardware/memory access and bringing down the system or compromising it. [Coding Horror+1](https://blog.codinghorror.com/understanding-user-and-kernel-mode/)
- *Resource isolation*: Each user-mode application gets its own virtual address space (so one user app can’t just overwrite another’s memory or the OS memory). [learn.microsoft.com+1](https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode)

### How the switch happens

- When a user-mode process needs to perform a privileged operation (e.g., read from disk, access hardware, allocate kernel memory, etc.), it must request a service from the kernel. This typically involves a *system call* or *trap/interrupt* that causes a transition from user mode → kernel mode. [Coding Horror+2Stack Overflow+2](https://blog.codinghorror.com/understanding-user-and-kernel-mode/)
- After the kernel has done its job and returned control, the CPU switches back (or remains) in user mode for the application.

### Key differences in table form

| Mode | Access to hardware | Memory access / isolation | Privilege / risk if crash |
| --- | --- | --- | --- |
| User mode | **No direct hardware access**; must go through kernel | Private virtual address space per process, cannot access kernel-reserved memory. [learn.microsoft.com+1](https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode) | Lower risk: crash usually only affects that process. |
| Kernel mode | **Direct hardware access**, full system resources | Shared virtual address space; kernel & drivers can access more memory. [learn.microsoft.com](https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode) | High risk: if something crashes, the whole OS may crash (e.g., Blue Screen). |

### Visual

!https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/images/userandkernelmode01.png

!https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Priv_rings.svg/1200px-Priv_rings.svg.png

!https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Windows_2000_architecture.svg/936px-Windows_2000_architecture.svg.png

---

## 2. How the Win32 API fits into this

Your text: *“Programs often need to access or modify Windows subsystems or hardware but are restricted… Micro­soft released the Win32 API…”*

Here’s how to map that to what’s really happening:

### What is the Win32 API

- The Win32 API (also called the Windows API) is the main set of functions provided by Microsoft for applications running on Windows to perform tasks like file I/O, memory allocation, process/thread creation, GUI operations, etc.
- This API is *exposed* to user-mode applications. When you write a normal Windows program (in C, C++, C#, etc.), you often call into kernel32.dll, user32.dll, gdi32.dll, etc., which provide those Win32 API functions. [Microsoft for Developers+1](https://devblogs.microsoft.com/oldnewthing/20230926-00/?p=108824&utm_source=chatgpt.com)

### Relationship to kernel mode

- When a Win32 API function needs to perform something that requires kernel privileges (e.g., interacting with hardware, file system driver, memory management, scheduling), it internally transitions into kernel mode via system calls.
- For instance: your app calls CreateFile() (user mode), that function eventually invokes a system call (native API) to the kernel to actually open the file. So the API is like a “gateway” from your user-mode application to kernel-mode services. [Stack Overflow+1](https://stackoverflow.com/questions/17952167/does-windows-api-give-one-access-to-the-kernel-or-is-it-more-complicated-than-th)
- Important nuance: the Win32 API itself does *not* run in kernel mode. It runs in user mode (in user-mode DLLs). What runs in kernel mode are the underlying OS kernel components or drivers. For example, kernel32.dll is still a user-mode DLL despite the word “kernel” in its name. [Microsoft for Developers](https://devblogs.microsoft.com/oldnewthing/20230926-00/?p=108824&utm_source=chatgpt.com)

### Why this matters

- Because applications are in user mode, they cannot directly “poke hardware” or “write to kernel memory”. That would compromise stability/security. So they must use the API, which ensures proper checks, isolation, and safe transitions.
- It also means that code running in user mode is isolated: if it misbehaves, it typically can’t crash the whole system. But once you're in kernel mode, a bug has big consequences.

### Example flow

Let's walk through a practical example:

1. Application in user mode calls the Win32 API: e.g., `CreateFile(L"C:\\myfile.txt", …)`.
2. Inside the Win32 API implementation (in kernel32.dll etc.), the function determines it requires kernel services. It makes a system call (via ntdll.dll → native API) into the kernel. [Wikipedia+1](https://en.wikipedia.org/wiki/Windows_Native_API)
3. CPU switches into kernel mode. Kernel (or a driver) performs the actual file open operation: access the file system driver, verify permissions, allocate internal structures, return a handle.
4. Kernel returns the result to user mode, CPU switches back. Application gets a handle and continues in user mode.
5. From this point the application can read/write via other API functions, etc.

So your earlier summary fits quite well:

- “User mode — no direct hardware access” = yes.
- “Kernel mode — direct hardware access” = yes.
- “API or system calls interface between each mode” = yes. The API is the user-mode front; system calls are the transition into kernel.
- The language runtime (e.g., .NET, Java, Python) sits above the API: your program code → runtime → Win32 API → native API → kernel.

---

## 3. How language runtimes fit in and “warp” the process

You mentioned “when looking at how languages interact with the Win32 API … the application will go through the language runtime before going through the API.” Let’s clarify that.

### Language runtime vs native calls

- If you write code in a high-level language (e.g., C#, Java, Python on Windows), you often run inside a runtime environment (e.g., .NET CLR, Java Virtual Machine, Python interpreter). That runtime sits in user mode.
- The runtime provides higher-level abstractions and then calls lower-level functions (which might invoke the Win32 API) to do system-level work.
- So the call path is roughly: your code → language runtime → Win32 API (or other interop calls) → native API → kernel mode.

### Why it matters for “warp”

- The additional runtime layer can introduce overhead, batching, marshaling, abstraction (e.g., memory management, garbage collection).
- From a security/reverse-engineering perspective, this means that when you’re analyzing how an application interfaces with hardware/subsystems, it might not call the Win32 API directly; instead it may call runtime-provided wrappers, P/Invoke, interop layers, etc.
- Also relevant for techniques like “runtime detection evasion”: malware or advanced tools might exploit or intercept runtime-API transitions rather than raw API calls.

### Diagram

![https://stackoverflow.com/questions/18250552/clr-win32-winrt-in-windows-architecture](attachment:3461a22f-c129-4145-b080-3507a21887c2:image.png)

!https://images.hanselman.com/blog/Windows-Live-Writer/How-to-call-WinRT-APIs-in-Windows-8-from_12FB4/image_14.png

!https://learn.microsoft.com/uk-ua/windows-hardware/drivers/gettingstarted/images/userandkernelmode01.png

---

## 4. Summary & Key Takeaways

- The distinction between user mode and kernel mode is fundamental to Windows OS architecture: protections, stability, isolation.
- The Win32 API is the standard user-mode interface that applications use, which ultimately triggers kernel services via system calls.
- Applications (especially high level language apps) often sit above a runtime, which then uses the Win32 API; so there is an extra layer between your program and the kernel.
- Understanding this layering is important when you’re doing low-level work (drivers, malware analysis, debugging, rootkits) because you’ll need to know when code transitions modes, where privileges lie, how a user-mode call becomes kernel-mode execution.
- For example: a user-mode application cannot simply access hardware ports or physical memory directly—doing so would require kernel mode access which the OS restricts.
- For your interest (bug bounty hunting / reverse shells / kernel vs user mode exploitation): knowing exactly how the transition happens, where the checks are, and where things might be intercepted or subverted is valuable.

---

## **Question 1:**

**How does malware intercept the runtime-API transition? And what's for?**

Short answer first: **malware intercepts runtime→API transitions by inserting itself between an application (or its language runtime) and the Windows API so the attacker can read/modify API calls or hide them**. Attackers do this for *evasion* (avoid EDR/AV), *credential capture*, *persistence*, or to *alter program behavior*. I’ll explain the common methods at a high level, why they’re used, and how defenders detect/mitigate them — with trusted references.

---

### How hooking / interception works (conceptual, non-actionable)

Below are the common *classes* of interception. I describe *what* they do and *why* attackers use them — without giving step-by-step instructions or code.

1. **DLL injection / process injection (place code inside a target process)**
    - Attackers force a trusted process to load a DLL or otherwise inject code so their code runs in that process’s address space. Once inside, they can intercept function calls issued inside the process (including those from language runtimes). This is a common precursor to hooking or to stealing credentials handled inside that process. (See MITRE Process Injection T1055). [attack.mitre.org+1](https://attack.mitre.org/techniques/T1055/)
2. **IAT / EAT hooking (Import/Export Address Table modifications)**
    - When a module imports a Windows function, the loader writes the function address into the module’s Import Address Table (IAT). An attacker can overwrite those IAT entries so calls go to malicious code first (then optionally forward to the original). This redirects API calls at the per-process level. [Microsoft for Developers+1](https://devblogs.microsoft.com/oldnewthing/20221006-07/?p=107257&utm_source=chatgpt.com)
3. **Inline (trampoline) hooking**
    - Instead of changing tables, the attacker overwrites the first bytes of an exported function with a jump to their code (a “trampoline”). Future callers get diverted. Libraries like Microsoft Detours implement the same idea for legitimate instrumentation; malicious actors use the same technique for stealth. [Protean Security+1](https://www.proteansec.com/exploit-development/api-hooking-detours/)
4. **User-mode API hook vs kernel-mode hook**
    - Hooks can live in user mode (affecting only a process or group of processes) or in kernel mode (affecting the whole system). Kernel hooks (or kernel drivers) can hide file/registry/network artifacts globally but are much higher risk to the system and more constrained by modern protections (driver signing, PatchGuard). [attack.mitre.org+1](https://attack.mitre.org/techniques/T0874/)
5. **Runtime / language-level hooking**
    - Higher-level runtimes (CLR/.NET, Python, Java) provide their own extension/profiler points, interop and JIT hooks. Adversaries can abuse those to intercept managed calls or to manipulate marshaling between managed code and native APIs. In other words, the “warp” you mentioned — a runtime adds another interception point before Win32 APIs. [Redfox Security - Pen Testing Services+1](https://redfoxsec.com/blog/introduction-to-edr-evasion-api-hooking/)
6. **Syscall bypass / direct syscalls**
    - EDRs often monitor the common user-mode API path (ntdll → kernel). Attackers sometimes call the kernel *directly* (direct syscalls) or otherwise craft calls to avoid detection hooks placed in userland stubs. Defenders have written detections specifically for these direct-syscall patterns. [Palo Alto Networks+1](https://www.paloaltonetworks.com/blog/security-operations/a-deep-dive-into-malicious-direct-syscall-detection/)

---

### Why attackers intercept API/runtime transitions

- **Evasion of monitoring:** If an EDR hooks `CreateProcess`/`VirtualAlloc`/etc. to watch for injection, diverting or modifying those calls can hide malicious behavior. [lumu.io+1](https://lumu.io/blog/edr-evasion/)
- **Credential or data capture:** Hooking input or credential-related APIs lets malware capture passwords, tokens or clipboard data before the program passes them to the OS. (MITRE: Input Capture). [attack.mitre.org](https://attack.mitre.org/techniques/T1056/004/)
- **Manipulate results / tamper logs:** Return altered values so security checks think operations succeeded/failed differently, or so forensic artifacts are suppressed. [cynet.com](https://www.cynet.com/attack-techniques-hands-on/api-hooking/)
- **Persistence & lateral movement:** Hooks can be used to hide persistence mechanisms (malicious DLLs, services) or to ensure malicious code runs whenever a particular process launches. [Red Canary+1](https://redcanary.com/threat-detection-report/techniques/dll-search-order-hijacking/)

---

### How defenders detect / mitigate these techniques (practical, high-level)

(These are defensive controls and detection ideas — safe and explicitly allowed.)

- **Monitor process injection and unusual memory writes**
    - Look for processes writing executable memory into other processes, creating remote threads, or suspicious `CreateRemoteThread`/`WriteProcessMemory` patterns. (MITRE guidance & advisories). [attack.mitre.org+1](https://attack.mitre.org/techniques/T1055/)
- **Detect altered imports / hooked stubs**
    - EDRs and integrity tools can compare in-memory function prologues / IAT entries against known good copies on disk or known DLL exports to find trampolines or modifications. Tools can enumerate hooks in ntdll/user32/gdi32 etc. [ired.team+1](https://www.ired.team/offensive-security/defense-evasion/detecting-hooked-syscall-functions)
- **Watch for direct syscalls and nonstandard syscall patterns**
    - Because direct syscall usage is a red flag, many vendors look for calls that bypass normal user-mode stubs or use odd syscall numbers. Palo Alto and other vendors publish telemetry/detections for this. [Palo Alto Networks](https://www.paloaltonetworks.com/blog/security-operations/a-deep-dive-into-malicious-direct-syscall-detection/)
- **Harden driver/kernel integrity**
    - Enforce driver signing, PatchGuard and Kernel-mode code signing so attackers can’t install unsigned kernel drivers that hide system artifacts. Microsoft documents kernel protections and detection engineering in their threat research posts. [microsoft.com](https://www.microsoft.com/en-us/security/blog/2022/06/30/using-process-creation-properties-to-catch-evasion-techniques/)
- **Telemetry: process creation properties, command line auditing, Sysmon**
    - Instrument process creation metadata, parent/child chains, unusual command lines, and DLL load events. Microsoft and threat-intel providers recommend using these signals to catch “suspicious process execution” families. [microsoft.com+1](https://www.microsoft.com/en-us/security/blog/2022/06/30/using-process-creation-properties-to-catch-evasion-techniques/)
- **Behavioral detection (not just signatures)**
    - Many hooking/evading techniques are polymorphic. Detect behavioral patterns (credential exfiltration, attempted API interception, abnormal memory access) rather than relying solely on static signatures. [lumu.io+1](https://lumu.io/blog/edr-evasion/)

### Quick reading list (trusted sources)

- MITRE ATT&CK — *Process Injection (T1055)* and *Input Capture* subtechniques. [attack.mitre.org+1](https://attack.mitre.org/techniques/T1055/)
- Microsoft Security Blog — research and detections on process creation/evasion patterns. [microsoft.com](https://www.microsoft.com/en-us/security/blog/2022/06/30/using-process-creation-properties-to-catch-evasion-techniques/)
- Palo Alto / vendor writeups on direct syscalls and detection. [Palo Alto Networks](https://www.paloaltonetworks.com/blog/security-operations/a-deep-dive-into-malicious-direct-syscall-detection/)
- Red Canary / Ired.Team / Cynet — practical explainers of API hooking techniques and defensive recommendations. [Red Canary+2ire](https://redcanary.com/threat-detection-report/techniques/process-injection/)

---

## **Question 2:**

Is it possible to do direct syscalls like without the usage of Windows API?

Short answer: **Yes — it’s possible to invoke kernel services without going through the normal Win32/ntdll stubs. That’s called a “direct syscall” (or manual/inline syscall), and adversaries use it to try to bypass user-mode hooks placed by AV/EDR.** But it’s nontrivial, fragile across Windows versions, and noisy from a detection point of view. Below I’ll explain *what* a direct syscall is, *how* attackers achieve it at a high level (no code), *why* they do it, and *how defenders can spot or mitigate it* — with trusted references.

### What “direct syscall” means

Normally a user-mode request that requires kernel privileges goes like this:

your app / runtime → Win32 API / ntdll stub → kernel (via the `syscall`/`sysenter` instruction) → kernel service executes → return.

A **direct syscall** means the user code builds the syscall parameters, resolves the correct syscall number, and executes the `syscall` (or equivalent) itself — bypassing the in-process `ntdll.dll` stub that most EDR/AV products hook/monitor. In effect, the code calls the kernel *directly* rather than calling the usual entry points that security products watch. [redops.at+1](https://redops.at/en/blog/direct-syscalls-a-journey-from-high-to-low)

### How attackers accomplish this (conceptual, not code)

Attackers who implement direct syscalls generally need to solve several problems:

1. **Resolve syscall numbers** — each native kernel service has a syscall ID that can change between Windows versions. Attackers must obtain the correct number for the target OS (from a clean `ntdll.dll` copy or runtime enumeration). [redops.at+1](https://redops.at/en/blog/direct-syscalls-a-journey-from-high-to-low)
2. **Prepare registers / stack** — kernel expects arguments in specific registers/locations before the `syscall` instruction. The caller must follow that ABI. [GitHub](https://github.com/VirtualAlllocEx/DEFCON-31-Syscalls-Workshop/wiki/04%3A-Chapter-2-%7C-Windows-OS-System-Calls)
3. **Execute the low-level instruction** — use `syscall` (x64) or `sysenter` (older) to transition to kernel mode. This bypasses whatever user-mode hooks were placed in the normal `ntdll` stub. [redops.at](https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls)
4. **Return handling** — ensure the kernel returns to a valid, expected user-mode return address; otherwise the kernel’s return path or stack checks can appear inconsistent and raise alarms. (Detection tips look for syscalls returning to nonstandard locations.) [winternl](https://winternl.com/detecting-manual-syscalls-from-user-mode/)

Because syscall numbers and calling conventions differ across Windows builds and architectures (x86/x64/WoW64), robust direct-syscall malware often includes logic to detect OS version and adapt dynamically — which adds complexity. [Cyber Security News+1](https://cyberpress.org/hackers-leverage-stealth-syscalls-technique/)

### Why attackers do this

- **Bypass user-mode hooks**: Many EDR/AV products instrument or hook `ntdll`/Win32 stubs in user-mode to inspect or block risky operations. Calling the kernel directly can evade those hooks. [Palo Alto Networks+1](https://www.paloaltonetworks.com/blog/security-operations/a-deep-dive-into-malicious-direct-syscall-detection/)
- **Avoid API-based telemetry**: Security products often rely on intercepting common API calls (e.g., `NtCreateThreadEx`, `NtAllocateVirtualMemory`) to raise alerts. Direct syscalls can avoid those monitored paths. [Elastic](https://www.elastic.co/guide/en/security/8.19/suspicious-process-access-via-direct-system-call.html)
- **Stealth for sensitive actions**: Credential dumping, remote code injection, or memory manipulation are common goals; doing them via direct syscalls reduces visibility to user-mode monitors. [redops.at+1](https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls)

Note: Direct syscalls are *not* a guaranteed cloak — they trade one detection surface (user-mode hooks) for others (odd callstacks, nonstandard return addresses, unusual syscall usage) that defenders can detect. [malwaretech.com+1](https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html)

### Limitations, risks and why it’s fragile

- **Windows version dependence** — syscall numbers and behaviors change; what works on one build can fail on another. Attackers must maintain per-version logic. [redops.at](https://redops.at/en/blog/direct-syscalls-a-journey-from-high-to-low)
- **Defender detection is maturing** — vendors and open-source projects now look for indicators of manual syscalls (e.g., returns to non-`ntdll` addresses, unexpected syscall numbers, unknown modules making syscalls). Elastic, Palo Alto, and others publish detections. [Palo Alto Networks+1](https://www.paloaltonetworks.com/blog/security-operations/a-deep-dive-into-malicious-direct-syscall-detection/)
- **Kernel protections** — modern kernel protections (PatchGuard, driver signing) make kernel-level evasions harder; kernel hooks are riskier for attackers and subject to enforcement. [Microsoft Learn](https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode)

### How defenders detect or mitigate direct syscalls

(Practical defensive guidance — safe to implement.)

- **Monitor for unusual syscall origins/returns** — look for syscalls that return to addresses outside known `ntdll`/Win32U code sections or that use unexpected numbers. Several detection writeups show this is a reliable signal. [winternl+1](https://winternl.com/detecting-manual-syscalls-from-user-mode/)
- **Telemetry on process memory operations** — flag processes that write executable pages, map memory, or create remote threads (common setup for manual syscalls and injection). Use Sysmon, EDR hooks, or ETW to collect these signals. [Stack Overflow+1](https://stackoverflow.com/questions/60167981/windows-native-functions-in-ntdll-dll-in-user-mode-moved-to-kernel-mode)
- **Integrity checks on ntdll/ntoskrnl** — compare in-memory prologues against disk images, and detect tampering (IAT/inline hooks). [linkedin.com+1](https://www.linkedin.com/pulse/direct-syscalls-xor-encryption-advanced-evasion-techniques-coyle-0epie)
- **Behavioral detections** — combine syscall anomalies with higher-level behaviors (credential access, lsass access, process injection) to reduce false positives. Vendors publish playbooks for investigating these behaviors. [Palo Alto Networks+1](https://www.paloaltonetworks.com/blog/security-operations/a-deep-dive-into-malicious-direct-syscall-detection/)

---

## **Question 3**

**Does launching an application as an administrator open the process in kernel mode?**

**Short answer:**

**No.** Running an application *as Administrator* does **not** make it run in kernel mode. It still runs entirely in **user mode** — just with **elevated privileges** (more permissions within user mode).

---

### 1. Administrator ≠ Kernel Mode

 **Administrator**

- An **Administrator** is a **user account** with more rights (like writing to system directories, changing services, or managing users).
- It still operates in **user mode**.
- Your process gets a **token** that says: “this process belongs to an admin,” and Windows checks that token before allowing privileged actions.

> Example: You can open the Registry Editor or delete protected files — because your security token grants you those privileges.
> 
> 
> But your program still cannot directly access hardware or physical memory — that’s only allowed in **kernel mode**.
> 

**Kernel Mode**

- Reserved for the **Windows kernel**, **device drivers**, and core system components (like `ntoskrnl.exe`, `hal.dll`).
- Code in kernel mode can:
    - Access any memory.
    - Talk directly to hardware (disks, network cards, etc.).
    - Crash the whole system if it fails (blue screen).

---

### 2. What actually happens when you “Run as Administrator”

When you right-click an app and choose **“Run as administrator”**, Windows:

1. Prompts via **UAC (User Account Control)**.
2. If confirmed, **creates a new process** with an **elevated security token**.
3. That token includes admin-level privileges, but the process still:
    - Executes in **user mode**.
    - Must still call **Win32 APIs** to interact with kernel mode.
    - Is isolated from kernel memory.

So, “Run as Administrator” gives you **authorization**, not **a kernel execution context**.

# Task-3: Components of Windows API

The Win32 API, more commonly known as the Windows API, has several dependent components that are used to define the structure and organization of the API.

Let’s break the Win32 API up via a top-down approach. We’ll assume the API is the top layer and the parameters that make up a specific call are the bottom layer. In the table below, we will describe the top-down structure at a high level and dive into more detail later.

| **Layer** | **Explanation** |
| --- | --- |
| API | A top-level/general term or theory used to describe any call found in the win32 API structure. |
| Header files or imports | Defines libraries to be imported at run-time, defined by header files or library imports. Uses pointers to obtain the function address. |
| Core DLLs | A group of four DLLs that define call structures. (KERNEL32, USER32, and ADVAPI32). These DLLs define kernel and user services that are not contained in a single subsystem. |
| Supplemental DLLs | Other DLLs defined as part of the Windows API. Controls separate subsystems of the Windows OS. ~36 other defined DLLs. (NTDLL, COM, FVEAPI, etc.) |
| Call Structures | Defines the API call itself and parameters of the call. |
| API Calls | The API call used within a program, with function addresses obtained from pointers. |
| In/Out Parameters | The parameter values that are defined by the call structures. |

Let’s expand these definitions; in the next task, we will discuss importing libraries, the core header file, and the call structure. In task 4, we will dive deeper into the calls, understanding where and how to digest call parameters and variants.

**Q1: What header file imports and defines the User32 DLL and structure?**

The primary header file that imports and defines the functions and structures related to the User32 DLL in the Windows API is `winuser.h`.

While `windows.h` is a common overarching header that includes many other Windows API headers, including `winuser.h`, you can directly include `winuser.h` if you only require the functionalities provided by User32.DLL.

**Example:**

```cpp
#include <windows.h> *// Includes winuser.h and other core headers// OR*
#include <winuser.h> // Only includes User32-related definitions
```

**Q2: What parent header file contains all other required child and core header files?**

The `windows.h` header file is the parent header file in Windows API programming that includes many other necessary child and core header files. Including `windows.h` provides access to a vast array of functions, data types, and macros for developing applications that interact with the Microsoft Windows operating system. This single header file serves as a convenient way to bring in the declarations and definitions required for various aspects of Windows programming, from user interface elements to file system operations and network communication.

# Task-4: OS Library

Before going into explaining the two concepts: **Windows File Header** and **P/Invoke**, we need to understand what is the difference between managed code and unmanaged code

## High-Level Idea

**Managed code** and **unmanaged code** differ in *who controls* the execution environment and *how memory, security, and errors* are managed.

| Type | Controlled by | Typical Language | Runs Under | Memory Handling | Example |
| --- | --- | --- | --- | --- | --- |
| **Managed Code** | **.NET CLR (Common Language Runtime)** | C#, VB.NET, F# | Managed runtime environment | Automatic (Garbage Collection) | C# application using `System.IO` |
| **Unmanaged Code** | **Operating System (no runtime)** | C, C++, Assembly | Directly on OS | Manual (malloc/free, pointers) | Win32 API app in C, native DLL, driver |

## 1. What Is Managed Code?

**Managed code** runs **inside a managed runtime**, most commonly the **.NET CLR (Common Language Runtime)**.

### Features

- **Memory management:** The CLR allocates and frees memory automatically using a *garbage collector (GC)*.
- **Type safety:** The CLR verifies that variables and operations are used safely.
- **Exception handling:** Unified, structured exception system.
- **Security checks:** Code Access Security (CAS) and sandboxing (in older .NET).
- **Cross-language interoperability:** Code written in C#, VB.NET, or F# compiles to the same *Intermediate Language (IL)* and runs under the same runtime.

### How it works

1. You write code in a managed language (e.g., C#).
2. The compiler converts it into **MSIL (Microsoft Intermediate Language)**, not native machine code yet.
3. At runtime, the CLR’s **Just-In-Time (JIT)** compiler translates that IL into **native code** for your CPU.
4. The CLR handles memory, exceptions, and threads while running your program.

> Reference: Microsoft Learn – Managed Execution Process
> 

---

## 2. What Is Unmanaged Code?

**Unmanaged code** runs **directly on the operating system** without a managed runtime like the CLR.

It’s compiled straight to **native machine code**, and **you are responsible** for memory and resource management.

### Characteristics

- No garbage collector — you must manually `malloc` and `free`.
- No automatic type safety — invalid pointers can crash your program.
- No built-in exception handling — must use mechanisms like `try/catch` in C++ or OS-level SEH.
- Executes **faster** (no runtime overhead), but **riskier** (no safety).

### How it works

1. You write in C, C++, or Assembly.
2. The compiler converts code directly to **machine code (PE executable)**.
3. The OS loader loads your program into memory, resolves its imports (DLLs, API functions), and executes it.
4. The program interacts with the OS via system calls (e.g., `kernel32.dll`, `ntdll.dll`).

> Reference: Microsoft Learn – Unmanaged Code Overview
> 

---

## 3. How Managed and Unmanaged Worlds Interact

Sometimes, managed code needs to use existing **unmanaged libraries** (e.g., the Win32 API).

That’s where **interop** mechanisms like **P/Invoke** come in.

| Situation | Example |
| --- | --- |
| Managed → Unmanaged | C# calls `MessageBoxW` from `user32.dll` using `[DllImport("user32.dll")]` |
| Unmanaged → Managed | Native C++ calls into a C# assembly using COM or C++/CLI |
| Both mixed | C++/CLI bridges between .NET and native C++ |

So, when you use P/Invoke in C#, you’re using *managed* code that temporarily steps into *unmanaged* territory to call a system function.

---

## 4. Summary Comparison

| Feature | Managed Code (.NET, CLR) | Unmanaged Code (C/C++, native) |
| --- | --- | --- |
| **Runtime environment** | CLR (Common Language Runtime) | Windows OS |
| **Compilation** | To IL (then JIT to native) | Direct to machine code |
| **Memory management** | Automatic (Garbage Collector) | Manual (malloc/free) |
| **Security model** | Type-safe, sandboxed | None, full access |
| **Performance** | Slightly slower due to runtime overhead | Typically faster |
| **Interoperability** | Can call native code via P/Invoke or COM | Must use interop APIs to call managed |
| **Common languages** | C#, VB.NET, F#, PowerShell | C, C++, Assembly |

## 💡 Example

### 🧱 Unmanaged (C++)

```cpp
#include <windows.h>
int main() {
    MessageBoxA(NULL, "Hello from unmanaged code!", "C++ Win32", MB_OK);
    return 0;
}
```

This is unmanaged code:

- Compiled directly to machine code.
- Calls Win32 API directly through headers (`windows.h`).
- Managed entirely by the OS.

### ⚙️ Managed (.NET / C#)

```csharp
using System;
using System.Runtime.InteropServices;

class Program {
    [DllImport("user32.dll", CharSet = CharSet.Ansi)]
    public static extern int MessageBoxA(IntPtr hWnd, string text, string caption, uint type);

    static void Main() {
        MessageBoxA(IntPtr.Zero, "Hello from managed code!", "C# PInvoke", 0);
    }
}
```

This is managed code:

- Runs inside the CLR.
- Uses **P/Invoke** to bridge into unmanaged Win32 API.
- CLR handles memory and exceptions.

## 1. Windows Header File (e.g., `windows.h`) for unmanaged C/C++

### What it is

- The file `windows.h` is a header file provided in the Windows SDK (*Software Development Kit*) for C and C++ programming on Windows. It declares the functions, data types, macros, structures etc. that make up the Windows API (Win32 API). [Wikipedia+2Microsoft Learn+2](https://en.wikipedia.org/wiki/Windows.h)
- In C or C++ you include `#include <windows.h>` (or include more specific header files) so your code knows about those API functions at compile time. [Microsoft Learn+1](https://learn.microsoft.com/en-us/windows/win32/winprog/using-the-windows-headers)
- The header file doesn’t actually *implement* the API functions; it gives you their declarations (signatures, types) and the compiler uses those to check your code. The actual functions are in DLLs (e.g., `user32.dll`, `kernel32.dll`, etc.). [cplusplus.com+1](https://cplusplus.com/forum/windows/112525/)

### Why this approach exists

- When writing unmanaged (native) C/C++ code, you need a way to call into the OS (Windows). The header + import libraries + DLLs provide that.
- The header lets you reference function names, types, macros, etc., and the linker + loader resolve the actual function addresses at runtime.
- Using headers makes the code portable (for Windows versions) and manageable, letting you compile against the API for 32-bit or 64-bit. [Microsoft Learn+1](https://learn.microsoft.com/en-us/windows/win32/winprog/using-the-windows-headers)

### How it works (high level)

1. You write C/C++ code and include `windows.h`.
2. You call a Win32 API function, say `CreateFile()`. The header has something like `WINBASEAPI HANDLE WINAPI CreateFile(...);` (simplified). The compiler knows the signature.
3. At link time (or at runtime for dynamic linking) the loader will ensure the correct DLL (e.g., `kernel32.dll`) is loaded and the function address is resolved (via the import table of your exe).
4. At runtime, when your program calls `CreateFile()`, your process in user mode executes a stub that jumps into the kernel (or calls into kernel mode via system call) (the mechanism behind the scenes).
5. Because of ASLR (Address Space Layout Randomization) and other mechanisms, the actual in-memory address of the function (and the DLL base) may vary per run. The loader handles that so your code doesn’t need to “find the pointer manually”.

### Why the note about “thunk table” / loader

- The text you showed mentions that “the loader will determine what calls are being made and create a thunk table to obtain function addresses or pointers.” This is essentially referring to the import address table (IAT) or the dynamic linking mechanism: the OS loader resolves the addresses of imported functions at load time, or uses stubs/thunks to patch them at run-time so you don’t have to manually find each function’s memory address.
- So when you include `windows.h`, call the function, you don’t manually compute its pointer; the loader and the DLL import machinery already take care of this. Microsoft documentation says the header files enable you to create apps and they include declarations; the loader resolves addresses. [Microsoft Learn+1](https://learn.microsoft.com/en-us/windows/win32/winprog/using-the-windows-headers)

### In sum for header file approach

- Use case: Unmanaged code (C or C++), you compile against Windows API.
- You include the header(s), link or import libraries/DLLs; runtime loader resolves actual function addresses (so you don’t need to manually handle ASLR for most functions).
- You’re directly calling the Win32 API from your code (and thus eventually crossing into kernel mode via system calls).
- Because this is native code, you don’t have “managed runtime” overhead (no CLR).

---

## 2. P/Invoke (Platform Invocation) for managed code (e.g., C#/.NET)

### What it is

- The term Platform Invocation Services (P/Invoke) refers to a feature of the .NET runtime that allows *managed code* (code running under the CLR like C#, VB.NET) to call *unmanaged functions* in DLLs (for example, Win32 API functions) that are not part of the .NET managed libraries. [Microsoft Learn+2Medium+2](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke)
- For example, in C# you mark a method with `[DllImport("user32.dll")]` (and other attributes) which tells the runtime how to load the DLL, how to convert (“marshal”) parameters, how to call the unmanaged function. Then you call that method just like any other C# method, but under the hood it invokes the native function. [tech-on-diapers.hashnode.dev](https://tech-on-diapers.hashnode.dev/c-interoperability-calling-unmanaged-code-with-pinvoke)

### Why this approach exists

- Managed code is easier and safer (garbage collection, type safety, etc.), but often you need to call system-level APIs (for example the Win32 API) or reuse legacy native libraries. .NET doesn’t automatically provide wrappers for *all* native APIs, so P/Invoke gives you a bridge. [Microsoft Learn+1](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke)
- You don’t have to rewrite the entire native function set; you can define the signature in managed code, and the runtime handles the interop. It lets you access hardware, OS features, or third-party native libraries from managed code. [DEV Community](https://dev.to/turalsuleymani/integrating-cc-libraries-to-net-applications-with-pinvoke-1n4c)

### How it works (high level)

1. In your managed code (e.g., C#), you declare something like:
    
    ```csharp
    [DllImport("user32.dll", CharSet=CharSet.Unicode, SetLastError=true)]
    private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType);
    ```
    
    This tells the CLR: “there is a function `MessageBox` in `user32.dll` with this signature”.
    
2. When you compile your managed code, the CLR (at runtime) will:
    - Load the native DLL if not already loaded.
    - Resolve the address of the unmanaged function (taking ASLR into account).
    - Generate or use an existing stub (interop/marshaling code) that translates between managed types (C# types) and unmanaged types (C types), e.g., `string` to `LPWSTR`, `IntPtr` to a pointer, etc.
    - The stub then calls the unmanaged function.
    - On return, it may convert (marshal) return values back into managed types. [Microsoft Learn+1](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke)
3. From your managed code you simply call `MessageBox(...)` and the bridging happens behind the scenes.

### How it relates to the pointer / ASLR concern

- Because the native function resides in a DLL that is subject to ASLR, the address of that DLL and its exported functions can vary each run. The P/Invoke mechanism (via CLR) ensures you don’t have to manually compute the pointer. The loader + interop code manage that resolution.
- So whether using header files or P/Invoke, you typically don’t *manually* compute the memory address of a Win32 function — the runtime/link loader handles it (import tables, dynamic load, etc.). The difference is *who* is doing it and *how*.

### In sum for P/Invoke

- Use case: Managed code (C#, VB.NET) needs to call unmanaged native functions (Windows API or other native libraries).
- You define the method signature, mark it with `DllImport`, runtime handles marshaling and resolution.
- You’re still ultimately calling the same native Win32 API functions that the unmanaged code would call; just via a managed bridge.

---

## 3. Compare the two approaches side-by-side

| Feature | Header File Approach (C/C++) | P/Invoke Approach (C#/.NET) |
| --- | --- | --- |
| Code environment | Unmanaged/native (C/C++) | Managed (.NET – C#, VB.NET) |
| How you reference API | `#include <windows.h>` (or specific Win32 headers) + link/ import libraries | `[DllImport(...)] extern ...` method declarations |
| Who resolves function pointers/address | Windows loader / import address table / DLL linking | CLR + native loader handle DLL + stub generation |
| Needs manual marshaling | You (the programmer) manage types directly | CLR marshals types (you may annotate marshaling behaviour) |
| Use case | Writing native OS-level code, drivers, etc. | Application code that wants to call native APIs |
| ASLR / function address handling | Handled by loader, you write code normally | Handled by runtime & loader, you write managed code normally |

---

## 4. Why this is relevant for your low-level / security work

Because you are studying network security, malware analysis, reverse shells, etc., understanding how functions in DLLs are resolved is important:

- When analyzing malware, you might see that code doesn’t call an API via the normal import table but instead computes the address of a function in a DLL manually (maybe to bypass import detection). Understanding both the native header approach and the managed P/Invoke approach helps you recognize these anomalies.
- For managed malware (e.g., .NET) that uses P/Invoke, you’ll want to look for `[DllImport]` declarations, or runtime code that uses `GetProcAddress`, `LoadLibrary`, or reflection to call native functions dynamically.
- For unmanaged code, you’ll want to look at how the import table is set up and whether code is bypassing the normal import mechanism (e.g., manually resolving function addresses, using inline syscalls, etc.), which is important for evasion.

---

## 5. A bit of nuance / extra details

- Just because you include `windows.h` in your C/C++ code doesn’t automatically guarantee the function pointers are resolved at compile time to absolute addresses — the actual addresses are resolved by the loader at runtime (especially for DLLs). That’s why ASLR is relevant. The header *declares* the functions; the import mechanism links them.
- With P/Invoke, managed code can call *any* native DLL (not only Windows API) as long as you declare the signature and it’s accessible. That means malware or security tools can call native code from .NET via P/Invoke.
- When dealing with marshaling in P/Invoke, you have to pay attention to parameter types, character encoding (Unicode vs ANSI), calling conventions (stdcall vs cdecl) etc., because mismatches can cause crashes. [Manski's Dev Log+1](https://manski.net/articles/csharp-dotnet/pinvoke-tutorial/part-1--basics)
- In recent .NET versions (e.g., .NET 7) there is a “source generation” feature for P/Invoke, which improves performance and reduces boilerplate interop code. [Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke-source-generation)

# Task-5: API Call Structure

I got confused about the difference between a library and a DLL, so here is the explanation:

## 1. Libraries vs DLLs

Both **libraries** and **DLLs** are collections of **compiled code** (functions, variables, classes, etc.) that can be **used by other programs**.

The main difference is *how and when* that code is linked and loaded into your program.

| Type | Meaning | When it’s linked | File extension | Typical use |
| --- | --- | --- | --- | --- |
| **Static Library** | Precompiled code *embedded* into your executable | **Compile time** | `.lib` (Windows) / `.a` (Linux) | Code merged directly into your `.exe` |
| **Dynamic Library (DLL)** | Precompiled code *loaded at runtime* | **Runtime** | `.dll` (Dynamic Link Library) | Shared code used by multiple programs |

## 2. Static Libraries (linked at compile time)

### ➤ What it is

A **static library** is a file (usually `.lib` in Windows or `.a` in Linux) that contains precompiled object code.

When you compile your program, the linker **copies** the needed functions from the library into your `.exe`.

### How it works

1. You compile a library, e.g., `math.lib`, which contains `add()` and `subtract()` functions.
2. When you build your program, the compiler links the required parts of `math.lib` into your executable.
3. The resulting `.exe` has *everything it needs inside it* — it doesn’t depend on external files.

### Advantages

- No external dependencies (your program can run standalone).
- Slightly faster at runtime (no loading needed).

### Disadvantages

- Increases executable size.
- If you update the library, you must recompile the program.
- Each app has its own copy in memory (no sharing).

## 3. Dynamic Libraries (linked at runtime → DLLs)

### ➤ What it is

A **DLL (Dynamic Link Library)** is a **dynamic library** — it contains compiled code that **multiple programs can share while running**.

Examples:

- `user32.dll` — GUI functions (MessageBox, windows, menus)
- `kernel32.dll` — core OS functions (file, process, memory handling)
- `ntdll.dll` — low-level system functions

### ⚙️ How it works

1. Your program doesn’t contain the DLL’s code — it contains **references** (function names) to functions in the DLL.
2. When your program starts, the **Windows loader** finds the DLL in memory (or loads it if not already loaded).
3. The loader fixes up pointers (Import Address Table / IAT) so that when your program calls the function, it jumps into the DLL code.

### Advantages

- Smaller executable size.
- Easier updates (replace one DLL, all programs benefit).
- Shared memory — only one copy of the DLL loaded for all processes.

### Disadvantages

- Dependency issues (“DLL Hell”) if wrong versions exist.
- A missing or corrupted DLL can crash the program.
- Slight runtime overhead to load and resolve functions.

## 4. How They Work Together

Sometimes you see both `.lib` **and** `.dll` for the same library — here’s why:

- The `.dll` contains the actual *code*.
- The `.lib` in that case is an **import library**, not a static library — it just contains symbols (metadata) that tell the linker where to find the functions in the `.dll`.

Example:

- You might link against `user32.lib` when building your C++ program.
- At runtime, Windows loads `user32.dll` automatically.

So:

```
user32.lib → used at compile/link time
user32.dll → used at runtime
```

- Reference:
- https://stackoverflow.com/questions/913691/dll-and-lib-files-what-and-why
- https://www.fortect.com/fix-dll-errors/difference-between-static-and-shared-libraries/?srsltid=AfmBOoo8H3foih6-ZENW91GqSQX9MRV-I78byD82m7M4yLMIA2-K_D_V

---

## 1) The A / W / “alias” naming scheme (what those suffixes mean)

- Win32 functions that deal with text commonly come in **two** flavors: an **ANSI** (8-bit code page) version and a **Unicode** (wide/UTF-16) version. Historically Microsoft marks them with an `A` or `W` suffix: e.g. `CreateFileA` (ANSI) and `CreateFileW` (Wide/Unicode). The generic name `CreateFile` is a compile-time alias that resolves to `CreateFileW` or `CreateFileA` depending on whether the `UNICODE` macro is defined when you build. [Microsoft Learn+1](https://learn.microsoft.com/en-us/windows/win32/intl/unicode-in-the-windows-api)
- **Why both exist:** for backward compatibility with older Windows and C runtime environments. Today most modern code (and Windows itself) prefers the `W` (Unicode) versions. [Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/intl/unicode-in-the-windows-api)
- **Ex suffix:** some APIs have extended variants (e.g., `MessageBoxEx`, `OpenProcessEx` if provided) that add parameters or broaden functionality. Note: Microsoft guidance discourages using `Ex` as a naming convention for new APIs, but historically some APIs include `Ex` to mean “extended”. Use the official doc page for each API to learn whether an `Ex` version exists. [Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions)

## 2) What the `[in]`, `[out]`, `[in, out]` annotations mean (I/O parameter semantics)

Microsoft’s API docs commonly mark each parameter with **annotation attributes** such as `[in]`, `[out]`, or `[in, out]`. These are documentation hints (and also used by tools) that describe the data flow:

- `[in]` — caller provides the data; the function **reads** this parameter. The callee should not attempt to write back through it.
- `[out]` — the function **writes** into this parameter to return data to the caller; the caller must typically provide a buffer or pointer.
- `[in, out]` — the caller provides initial data and the function may modify it (both read and write). [Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory)

These annotations matter for two reasons:

1. **Correct use:** they tell you whether you must allocate a buffer before calling, or pass a pointer to receive results.
2. **Interop/marshaling:** when calling from managed code (P/Invoke), the CLR uses this information (and additional marshaling attributes) to copy data into/out of native calls correctly.

## 3) Common Win32 parameter types — what they mean in plain language

You’ll see a lot of typedefs. Here are the ones in your `WriteProcessMemory` example:

- `BOOL` — 32-bit integer return (nonzero = success, zero = failure). On failure, call `GetLastError()` to get the error code. [Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
- `HANDLE` — an opaque handle (like an integer) referencing a kernel object (process, file, etc.). Not a pointer to memory — it’s a reference that the OS uses. [Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)
- `LPVOID` — pointer to memory (mutable). Stands for *Long Pointer to VOID*; in prototypes it means *a pointer to writable memory* (e.g., destination buffer).
- `LPCVOID` — pointer to constant data (read-only in intent). The `C` stands for *const* (literal: Long Pointer to Constant VOID).
- `SIZE_T` — unsigned integer type used to represent byte sizes (platform dependent: 32-bit on x86, 64-bit on x64).
- `LPDWORD` / `SIZE_T*` — pointer to an integer that the function will write into (used for `[out]` parameters returning how many bytes were written/read). [Microsoft Learn+1](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)

## 4) Walkthrough: `WriteProcessMemory` — param by param (what each one expects)

Prototype:

```c
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,
  [in]  LPCVOID lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
);
```

- `hProcess` (`[in] HANDLE`): handle to the **target** process whose memory you want to write. The handle must have the right access (e.g., `PROCESS_VM_WRITE` and `PROCESS_VM_OPERATION` — see the OpenProcess docs). If you opened the handle without sufficient rights, the call fails. [Microsoft Learn+1](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)
- `lpBaseAddress` (`[in] LPVOID`): the target **address in the *target process*** where the write should start. It is interpreted in the target process’s virtual address space. (On failure the function returns zero.) [Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
- `lpBuffer` (`[in] LPCVOID`): a pointer **in the caller’s process** to the buffer whose bytes will be copied to the target process. The function reads from this buffer in your process and writes into the target process. (This is why your process must pass a valid pointer and size.)
- `nSize` (`[in] SIZE_T`): number of bytes to copy.
- `lpNumberOfBytesWritten` (`[out] SIZE_T*`): optional pointer in the caller’s process that the function writes the actual number of bytes written. It can be `NULL` if you don’t need that detail. If the function fails, this value may be undefined — check return value and `GetLastError()`.
- **Return:** `BOOL` (nonzero success). On failure call `GetLastError()` to learn why. In managed P/Invoke you often use `SetLastError = true` on the `DllImport` attribute so calls to `Marshal.GetLastWin32Error()` return the proper error.

# Task-6: C API Implementation

Microsoft provides low-level programming languages such as C and C++ with a pre-configured set of libraries that we can use to access needed API calls.

The `windows.h` header file, as discussed in task 4, is used to define call structures and obtain function pointers. To include the windows header, prepend the line below to any C or C++ program.

`#include <windows.h>`

Let’s jump right into creating our first API call. As our first objective, we aim to create a pop-up window with the title: “Hello THM!” using `CreateWindowExA`. To reiterate what was covered in task 5, let’s observe the in/out parameters of the call.

```cpp
HWND CreateWindowExA(
  [in]           DWORD     dwExStyle, // Optional windows styles
  [in, optional] LPCSTR    lpClassName, // Windows class
  [in, optional] LPCSTR    lpWindowName, // Windows text
  [in]           DWORD     dwStyle, // Windows style
  [in]           int       X, // X position
  [in]           int       Y, // Y position
  [in]           int       nWidth, // Width size
  [in]           int       nHeight, // Height size
  [in, optional] HWND      hWndParent, // Parent windows
  [in, optional] HMENU     hMenu, // Menu
  [in, optional] HINSTANCE hInstance, // Instance handle
  [in, optional] LPVOID    lpParam // Additional application data
);
```

Let’s take these pre-defined parameters and assign values to them. As mentioned in task 5, each parameter for an API call has an explanation of its purpose and potential values. Below is an example of a complete call to `CreateWindowsExA`.

```cpp
HWND hwnd = CreateWindowsEx(
	0,
	CLASS_NAME,
	L"Hello THM!",
	WS_OVERLAPPEDWINDOW,
	CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
	NULL,
	NULL,
	hInstance,
	NULL
	);
```

We’ve defined our first API call in C! Now we can implement it into an application and use the functionality of the API call. Below is an example application that uses the API to create a small blank window.

```cpp
BOOL Create(
        PCWSTR lpWindowName,
        DWORD dwStyle,
        DWORD dwExStyle = 0,
        int x = CW_USEDEFAULT,
        int y = CW_USEDEFAULT,
        int nWidth = CW_USEDEFAULT,
        int nHeight = CW_USEDEFAULT,
        HWND hWndParent = 0,
        HMENU hMenu = 0
        )
    {
        WNDCLASS wc = {0};

        wc.lpfnWndProc   = DERIVED_TYPE::WindowProc;
        wc.hInstance     = GetModuleHandle(NULL);
        wc.lpszClassName = ClassName();

        RegisterClass(&wc);

        m_hwnd = CreateWindowEx(
            dwExStyle, ClassName(), lpWindowName, dwStyle, x, y,
            nWidth, nHeight, hWndParent, hMenu, GetModuleHandle(NULL), this
            );

        return (m_hwnd ? TRUE : FALSE);
    }

```

If successful, we should see a window with the title “Hello THM!”.

As demonstrated throughout this task, low-level languages make it very easy to define an API call quickly. Because of the ease of use and extensibility, C-based languages are the most popular among threat actors and vendors alike.

# Task-7: .NET and PowerShell API Implementations

As discussed in task 4, **P/Invoke** allows us to import DLLs and assign pointers to API calls.

To understand how P/Invoke is implemented, let’s jump right into it with an example below and discuss individual components afterward.

```cpp
class Win32 {
	[DllImport("kernel32")]
	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
}
```

The class function stores defined API calls and a definition to reference in all future methods.

The library in which the API call structure is stored must now be imported using `DllImport`. The imported DLLs act similar to the header packages but require that you import a specific DLL with the API call you are looking for. You can reference the [API index](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) or [pinvoke.net](http://pinvoke.net/) to determine where a particular API call is located in a DLL.

From the DLL import, we can create a new pointer to the API call we want to use, notably defined by `intPtr`. Unlike other low-level languages, you must specify the in/out parameter structure in the pointer. As discussed in task 5, we can find the in/out parameters for the required API call from the Windows documentation.

Now we can implement the defined API call into an application and use its functionality. Below is an example application that uses the API to get the computer name and other information of the device it is run on.

```csharp
class Win32 {
	[DllImport("kernel32")]
	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
}

static void Main(string[] args) {
	bool success;
	StringBuilder name = new StringBuilder(260);
	uint size = 260;
	success = GetComputerNameA(name, ref size);
	Console.WriteLine(name.ToString());
}
```

If successful, the program should return the computer name of the current device.

Now that we’ve covered how it can be accomplished in .NET let’s look at how we can adapt the same syntax to work in PowerShell.

Defining the API call is almost identical to .NET’s implementation, but we will need to create a method instead of a class and add a few additional operators.

```powershell
$MethodDefinition = @"
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32")]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
"@;
```

The calls are now defined, but PowerShell requires one further step before they can be initialized. We must create a new type for the pointer of each Win32 DLL within the method definition. The function `Add-Type` will drop a temporary file in the `/temp` directory and compile needed functions using `csc.exe`. Below is an example of the function being used.

```powershell
$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru;
```

We can now use the required API calls with the syntax below.

`[Win32.Kernel32]::<Imported Call>()`

**Question 1: What method is used to import a required DLL?**

- A: DllImport

**Question 2 : What type of method is used to reference the API call to obtain a struct?**

- A: External

# Task-8: Commonly Abused API Calls

Several API calls within the Win32 library lend themselves to be easily leveraged for malicious activity.

Several entities have attempted to document and organize all available API calls with malicious vectors, including [SANs](https://www.sans.org/white-papers/33649/) and [MalAPI.io](http://malapi.io/).

While many calls are abused, some are seen in the wild more than others. Below is a table of the most commonly abused API organized by frequency in a collection of samples.

| **API Call** | **Explanation** |
| --- | --- |
| LoadLibraryA | Maps a specified DLL  into the address space of the calling process |
| GetUserNameA | Retrieves the name of the user associated with the current thread |
| GetComputerNameA | Retrieves a NetBIOS or DNS  name of the local computer |
| GetVersionExA | Obtains information about the version of the operating system currently running |
| GetModuleFileNameA | Retrieves the fully qualified path for the file of the specified module and process |
| GetStartupInfoA | Retrieves contents of STARTUPINFO structure (window station, desktop, standard handles, and appearance of a process) |
| GetModuleHandle | Returns a module handle for the specified module if mapped into the calling process's address space |
| GetProcAddress | Returns the address of a specified exported DLL  function |
| VirtualProtect | Changes the protection on a region of memory in the virtual address space of the calling process |

# Task-9: Malware use case

Now that we understand the underlying implementations of the Win32 library and commonly abused API calls, let’s break down two malware samples and observe how their calls interact.

In this task, we will be breaking down a C# keylogger and shellcode launcher.

## Keylogger

To begin analyzing the keylogger, we need to collect which API calls and hooks it is implementing. Because the keylogger is written in C#, it must use P/Invoke to obtain pointers for each call. Below is a snippet of the p/invoke definitions of the malware sample source code.

```csharp
[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);
[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool UnhookWindowsHookEx(IntPtr hhk);
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr GetModuleHandle(string lpModuleName);
private static int WHKEYBOARDLL = 13;
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr GetCurrentProcess();

```

Below is an explanation of each API call and its respective use.

| **API Call** | **Explanation** |
| --- | --- |
| SetWindowsHookEx | Installs a memory hook into a hook chain to monitor for certain events |
| UnhookWindowsHookEx | Removes an installed hook from the hook chain |
| GetModuleHandle | Returns a module handle for the specified module if mapped into the calling process's address space |
| GetCurrentProcess | Retrieves a pseudo handle for the current process. |

To maintain the ethical integrity of this case study, we will not cover how the sample collects each keystroke. We will analyze how the sample sets a hook on the current process. Below is a snippet of the hooking section of the malware sample source code.

```csharp
public static void Main() {
	_hookID = SetHook(_proc);
	Application.Run();
	UnhookWindowsHookEx(_hookID);
	Application.Exit();
}
private static IntPtr SetHook(LowLevelKeyboardProc proc) {
	using (Process curProcess = Process.GetCurrentProcess()) {
		return SetWindowsHookEx(WHKEYBOARDLL, proc, GetModuleHandle(curProcess.ProcessName), 0);
	}
}
```

Let’s understand the objective and procedure of the keylogger, then assign their respective API call from the above snippet.

Using the [Windows API documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) and the context of the above snippet, begin analyzing the keylogger, using questions 1 - 4 as a guide to  work through the sample.

### Q&A

1. What Win32 API call is used to obtain a pseudo handle of our current process in the keylogger sample?
    1. *GetCurrentProcess*
2. What Win32 API call is used to set a hook on our current process in the keylogger sample?
    1. *SetWindowsHookEx*
3. What Win32 API call is used to obtain a handle from the pseudo handle in the keylogger sample?
    1. *GetModuleHandle*
4. What Win32 API call is used unset the hook on our current process in the keylogger sample?
    1. *UnhookWindowsHookEx*

## Shellcode Launcher

To begin analyzing the shellcode launcher, we once again need to collect which API calls it is implementing. This process should look identical to the previous case study. Below is a snippet of the p/invoke definitions of the malware sample source code.

```csharp
private static UInt32 MEM_COMMIT = 0x1000;
private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
[DllImport("kernel32")]
private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
[DllImport("kernel32")]
private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
[DllImport("kernel32")]
private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

```

Below is an explanation of each API call and its respective use.

| **API Call** | **Explanation** |
| --- | --- |
| VirtualAlloc | Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. |
| WaitForSingleObject | Waits until the specified object is in the signaled state or the time-out interval elapses |
| CreateThread | Creates a thread to execute within the virtual address space of the calling process |

We will now analyze how the shellcode is written to and executed from memory.

```csharp
UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
IntPtr hThread = IntPtr.Zero;
UInt32 threadId = 0;
IntPtr pinfo = IntPtr.Zero;
hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
WaitForSingleObject(hThread, 0xFFFFFFFF);
return;

```

Let’s understand the objective and procedure of shellcode execution, then assign their respective API call from the above snippet.

Using the [Windows API documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) and the context of the above snippet, begin analyzing the shellcode launcher, using questions 5 - 8 as a guide to  work through the sample.

### Q&A

1. What Win32 API call is used to allocate memory for the size of the shellcode in the shellcode launcher sample?
    1. *VirtualAlloc*
2. What native method is used to write shellcode to an allocated section of memory in the shellcode launcher sample?
    1. *Marshal.copy*
3. What Win32 API call is used to create a new execution thread in the shellcode launcher sample?
    1. *CreateThread*
4. What Win32 API call is used to wait for the thread to exit in the shellcode launcher sample?
    1. *WaitForSingleObject*
