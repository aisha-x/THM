# x86 Architecture room summary


Room URL: https://tryhackme.com/room/x8664arch

## **Learning Objectives:**

Summing up, we will be covering the following topics in this room.

- Overview of CPU architecture and its components
- Different types of CPU registers and their usage
- Memory layout as viewed by a program
- Stack layout and stack registers

# CPU Architecture Overview

The most widely used CPU design is based on the **Von Neumann architecture**, which organizes the system into the **CPU, memory, and I/O devices**. The CPU itself contains three main components:

<img width="2048" height="1247" alt="image" src="https://github.com/user-attachments/assets/e219b817-e951-4952-8511-852dcef4068a" />

1. **Control Unit (CU):**
    - Directs the flow of data and instructions inside the CPU.
    - Fetches instructions from **main memory** using the **Instruction Pointer (IP)** (EIP in 32-bit, RIP in 64-bit systems).
    - Decodes instructions and sends signals to the ALU, registers, and other parts of the system to coordinate execution.
2. **Arithmetic Logic Unit (ALU):**
    - Executes operations such as arithmetic (addition, subtraction, multiplication, division) and logical comparisons (AND, OR, NOT).
    - Produces results that are stored in registers or written back to memory.
3. **Registers:**
    - Small, high-speed storage locations inside the CPU.
    - Hold data, instructions, and addresses temporarily for quick access.
    - Examples: **Accumulator**, **Instruction Register (IR)**, **Stack Pointer (SP)**, and **Program Counter (PC/IP)**.
    - Much faster than RAM, making them essential for efficient processing.
4. **Memory (Main Memory/RAM):**
    - Stores both program instructions and data.
    - Works on the principle of **Random Access**, allowing the CPU to fetch any location directly.
    - Limited in speed compared to registers, which is why registers exist as an intermediary.
5. **I/O Devices:**
    - Enable interaction between the computer and the external environment (e.g., keyboard, mouse, display, printers, storage devices).
    - Managed by the CPU through input/output instructions and device controllers.

### Additional Key Details (from trusted sources like computer architecture textbooks & OS design references):

- **Von Neumann Bottleneck:** Since instructions and data share the same memory and bus, performance can be limited by the speed of data transfer between CPU and memory. This led to the development of **Harvard architecture**, where instructions and data use separate pathways.
- **Instruction Cycle (Fetch–Decode–Execute):**
    1. **Fetch** – Control Unit gets the next instruction from memory (using IP/PC).
    2. **Decode** – Instruction is interpreted to determine the operation.
    3. **Execute** – ALU or CU carries out the operation, storing results in registers or memory.
- **Clock Speed & Pipelining:** Modern CPUs use high-frequency clocks and **instruction pipelining** (overlapping fetch, decode, and execute stages) to increase throughput.
- **Cache Memory:** Modern architectures also introduce **cache** (L1, L2, L3) between registers and RAM to reduce memory access delays. Cache stores frequently used data closer to the CPU.

# CPU Registers Overview

Registers are the **fastest storage elements** inside the CPU, used to hold data, addresses, and status information temporarily. They are limited in size but critical for performance. Registers in the x86/x86-64 architecture are divided into four main types:

---

### 1. **Instruction Pointer (Program Counter)**

- Holds the **address of the next instruction** to execute.
- Known as **IP** (16-bit), **EIP** (32-bit), and **RIP** (64-bit).
- Automatically updated after each instruction.

---

### 2. **General-Purpose Registers (GPRs)**

Used for arithmetic, data storage, memory access, and addressing. They are accessible in multiple sizes (64-bit, 32-bit, 16-bit, 8-bit).

- **RAX / EAX / AX / AH–AL** → Accumulator Register (stores arithmetic results).
- **RBX / EBX / BX / BH–BL** → Base Register (used for memory addressing).
- **RCX / ECX / CX / CH–CL** → Counter Register (used in loops, shifts).
- **RDX / EDX / DX / DH–DL** → Data Register (used in division/multiplication).
- **RSP / ESP / SP** → Stack Pointer (points to top of stack).
- **RBP / EBP / BP** → Base Pointer (used for stack frame and parameters).
- **RSI / ESI / SI** → Source Index (used in string/memory operations).
- **RDI / EDI / DI** → Destination Index (used in string/memory operations).
- **R8–R15** → Extra 64-bit registers introduced in x86-64 for more flexibility.

<img width="2048" height="2468" alt="image" src="https://github.com/user-attachments/assets/e9d53a2a-65fc-4f11-8978-f36ecd822ddc" />

---

### 3. **Status Flag Registers (EFLAGS/RFLAGS)**

Store **execution results and CPU state** in single-bit flags. Examples:

- **ZF (Zero Flag):** Set if result = 0.
- **CF (Carry Flag):** Set if overflow/underflow occurs.
- **SF (Sign Flag):** Set if result is negative.
- **TF (Trap Flag):** Enables single-step debugging mode.

---

### 4. **Segment Registers (16-bit)**

Used in memory segmentation (more important in older x86, less in modern flat memory models).

- **CS (Code Segment):** Points to code section.
- **DS (Data Segment):** Points to data section.
- **SS (Stack Segment):** Points to stack.
- **ES, FS, GS:** Extra data segments for additional memory addressing.

---

✅ **In short:**

Registers provide the CPU with **fast, direct-access storage**. The Instruction Pointer tracks instructions, General-Purpose Registers handle computation and addressing, Status Flags record outcomes of operations, and Segment Registers help organize memory access.

# Memory Overview

## Memory layout summary (what a Windows program sees)

When Windows loads a program each process gets an **abstracted view of memory** (its own virtual address space). The program only “sees” and uses that private address space — the OS manages the real physical memory and the mapping.

Typical sections inside a program’s memory (as a process sees them):

- **Code (text)** — contains the program’s executable instructions (from the PE file’s ). Usually marked **execute** (and read) by the OS.
- **Data** — holds initialized, static data (globals, constants). Comes from the PE data sections and is typically readable and writable depending on attributes.
- **Heap (dynamic)** — used for runtime allocations (malloc/`HeapAlloc`/`new`). Grows and shrinks at runtime; lifetime of items is managed by the program.
- **Stack** — stores function return addresses, local variables, and call arguments. Because it controls return flow, it’s a common target for exploits (e.g., buffer overflows) and is therefore security-sensitive.
    
    <img width="1489" height="2321" alt="image" src="https://github.com/user-attachments/assets/fb8132e4-d999-4e9e-987f-36b192d90ae7" />

    

Key points:

- The order/placement of these regions can vary between processes and platforms (ASLR and compiler/linker choices affect layout).
- Memory permissions matter (read/write/execute) — modern systems use protections (NX/DEP, ASLR) to make exploitation harder.
- For reverse-engineering and malware analysis, focus on **code** (what runs), **heap** (dynamic data/objects), and **stack** (control flow/state), since these reveal program behavior and common attack vectors.

## Memory Layout & Registers — Quick Cheat-Sheet

**Purpose:** compact reference for reverse engineering / malware analysis on Windows — memory regions, registers, permissions, common tools, and quick notes.

---

### 1. At a glance (process virtual address space)

```
(high addresses)
[ Stack (per-thread)      ]  <- grows down
[ Unused / mapped views   ]
[ Heap (dynamic)          ]  <- grows up
[ BSS / .data (writable)  ]
[ .rdata (read-only data) ]
[ .text / code (executable)]
[ PE headers / imports    ]
(low addresses)

```

---

### 2. Sections & what to look for

- **Code / .text**
    - Contains executable instructions.
    - Look for: suspicious imports, packed/encrypted code, injected code pages.
    - Permissions: typically **RX** (read+execute).
- **Data / .data / .rdata**
    - Static globals, constants, import tables.
    - Look for: hardcoded strings, config, function pointers.
    - Permissions: **R/W** (data), **R** (read-only data).
- **Heap**
    - Dynamically allocated memory (malloc, HeapAlloc, new).
    - Look for: runtime-created structures, decrypted payloads, hooks.
    - Behavior: alloc/free patterns, fragmentation, use-after-free.
- **Stack (per thread)**
    - Local vars, return addresses, saved registers, function args.
    - Look for: overflow attempts, return-oriented programming (ROP) gadgets.
    - Permissions: usually **R/W**, sometimes **NX** on modern systems.
- **Mapped files / DLLs / Memory-mapped views**
    - DLL code/data, mapped resources, injected payloads.

---

### 3. Memory protections & mitigations (what defenders/malware authors care about)

- **R/W/X flags** — read / write / execute. Executable writable memory is dangerous.
- **NX / DEP** — non-executable data pages; makes execution-only-in-code harder.
- **ASLR** — address space layout randomization; randomizes base addresses (process/DLL/stack/heap).
- **CET / CFG / Control-Flow Integrity** — modern control-flow protections (platform-dependent).

---

### 4. Registers (quick reference)

- **IP (Instruction Pointer)/ Program Counter:** `IP` (16-bit), `EIP` (32-bit), `RIP` (64-bit) — address of next instruction.
- **General-purpose:** `RAX/EAX/AX`, `RBX/EBX`, `RCX/ECX`, `RDX/EDX`, `RSP/ESP` (stack pointer), `RBP/EBP` (base/frame pointer), `RSI/ESI`, `RDI/EDI`, `R8–R15` (x86-64).
- **Flags:** `EFLAGS/RFLAGS` — `ZF` (zero), `CF` (carry), `SF` (sign), `TF` (trap/single-step), etc.
- **Segment regs:** `CS`, `DS`, `SS`, `ES`, `FS`, `GS` (mostly legacy/OS-managed in flat model).

---

### 5. Common investigation goals & hints

- **Find code stubs / unpackers:** search for RWX pages, unusual mapped sections, or memory that becomes executable at runtime.
- **Extract decrypted payloads:** monitor heap allocations and scan for PE headers (`MZ` / `PE`) in memory.
- **Trace control flow:** examine stack for return addresses, saved RIP/EIP; use single-step (TF) or breakpoints.
- **Detect code injection:** look for threads whose start address points into heap or mapped anonymous regions.
- **Identify hooks / IAT manipulation:** check import table entries and compare to known DLL exports.

---

### 6. Quick tools & useful commands

**GUI / Sysinternals**

- `Process Explorer` — view process modules, handles, threads, memory regions.
- `VMMap` (Sysinternals) — detailed mapped/commit view of a process.
- `Process Hacker` — alternative with memory map view.

**Debugger / low-level**

- `WinDbg` / `x64dbg` / `OllyDbg` — breakpoints, memory dumps, stack traces.
    - WinDbg commands: `!address -summary` (memory regions), `!heap` (heap info), `~* k` (thread stacks).
- `procdump` — dump process memory for offline analysis.

**Forensics / scanning**

- `strings` on memory dump — quick string extraction.
- `Volatility` / `Rekall` — memory forensic frameworks for full-memory analysis (useful in incident response).

**Linux equivalents (if relevant)**

- `pmap <pid>`, `/proc/<pid>/maps`, `gdb`.

---

### 7. Short checklist for a quick triage

1. Identify suspicious processes (unusual parent, path, name).
2. Capture memory or process dump.
3. Use `VMMap` / debugger to list **RWX** pages and newly mapped/executable pages.
4. Search memory for `MZ`/`PE` headers and strings (C2, keys).
5. Inspect stacks of all threads for unexpected return addresses or shellcode entry points.
6. Dump suspicious pages to disk and analyze offline (disasm, entropy, strings).

---

### 8. One-page printable summary (copyable)

- **Code** = executable `.text` → check imports / entry points.
- **Data** = static config / globals → check strings.
- **Heap** = runtime allocations → check for decrypted payloads.
- **Stack** = return addresses / locals → check for overflows / ROP.
- **Flags** = `EFLAGS/RFLAGS` show instruction outcomes.
- **Tools:** `VMMap`, `Process Explorer`, `WinDbg`, `x64dbg`, `Volatility`.

# Stack Layout

**Summary**

- The **stack** is a per-thread LIFO region in a process’s virtual memory that holds **function arguments, local variables, saved frame pointers, and the return address** used for control flow. [ctf101.org+1](https://ctf101.org/binary-exploitation/what-is-the-stack/)
- Two CPU registers track it: **Stack Pointer** (`ESP` / `RSP`) points at the top of the stack and changes with `push`/`pop` and allocations; **Base/Frame Pointer** (`EBP` / `RBP`) typically marks a stable frame base for the current function so locals/args have fixed offsets. [Stack Overflow+1](https://stackoverflow.com/questions/14296088/what-is-this-assembly-function-prologue-epilogue-code-doing-with-rbp-rsp-l)
- A typical stack frame (from high → low addresses) contains: function arguments (or saved incoming registers), return address, saved old base pointer, then local variables. The **function prologue** creates this frame (push old `BP`, `mov BP, SP`, allocate locals); the **epilogue** restores it (`mov SP, BP`/`pop BP`, `ret`). [Microsoft for Developers+1](https://devblogs.microsoft.com/oldnewthing/20040116-00/?p=41023)

<img width="2048" height="2979" alt="image" src="https://github.com/user-attachments/assets/fa79af99-14ef-4466-b72e-8e466838cd12" />

**Why it matters for reverse engineering & malware analysis**

- Because the **return address** lives on the stack, overwriting it via a buffer overflow lets an attacker hijack control flow (classic stack-based buffer overflow / return address overwrite). Detecting/modifying these stack contents is central to exploit analysis. [owasp.org+1](https://owasp.org/www-community/attacks/Buffer_overflow_attack)

---

## Additional trusted details & useful notes

**Calling conventions (why offsets and stack layout differ)**

- Calling conventions (e.g., `__cdecl`, `__stdcall` on x86; Microsoft x64 ABI on 64-bit Windows) determine *who* pushes arguments, whether arguments go in registers or on the stack, and who cleans up the stack. On Windows x64, the first integer/pointer args are passed in `RCX`, `RDX`, `R8`, `R9`; extra args are pushed to the stack and a 32-byte "shadow space" is reserved by the caller. This affects where you look for parameters in a debugger. [Microsoft Learn+1](https://learn.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-170)

**Compiler/architecture optimizations**

- Modern compilers sometimes omit frame pointers (frame-pointer omission / “-fomit-frame-pointer”), so `RBP/EBP` may be used as a general register and there’s no fixed `BP`based frame — instead use `RSP` offsets or unwind metadata to examine the stack. This makes static stack analysis slightly different on optimized builds. [cs.brown.edu](https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf)

**Common exploit mitigations you’ll encounter**

- **Stack canaries / GS**: compilers insert a small guard value (canary) between locals and the saved BP/return address; overwriting the canary usually crashes the program instead of returning to attacker code.
- **NX / DEP**: non-executable data pages prevent running code on the stack (requires return-oriented or other techniques).
- **ASLR**: randomizes base addresses (stack, heap, modules), making absolute addresses less predictable for attackers.
- **Control-Flow Integrity / Shadow Stacks**: newer OS/CPU features attempt to validate return-flow or keep a protected shadow stack to prevent return-address tampering.
    
    These mitigations are why modern malware may use techniques like ROP, JIT/shellcode staging, or return-to-libc rather than simple shellcode on the stack. [owasp.org+1](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)
    

**Forensics / reverse-engineering tips**

- When analyzing a crash or exploit: examine the thread stack(s) for corrupted return addresses, saved registers, and attacker strings/payloads. Tools: WinDbg (`~* k` for stacks), x64dbg/OllyDbg (interactive stack view), VMMap/Process Explorer for memory permissions (look for RWX pages). [Microsoft Learn+1](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170)
- Look for patterns: unusual RWX stack/heap pages, high-entropy regions (packed/encrypted code), `MZ`/`PE` headers in memory (dropped or in-memory loaders). These often show how malware stages and gains execution. [ctf101.org+1](https://ctf101.org/binary-exploitation/what-is-the-stack/)

**Small reference: common prologue / epilogue (classic x86 example)**

```
push ebp
mov  ebp, esp
sub  esp, <locals_size>     ; allocate locals
... function body ...
mov  esp, ebp               ; or use `leave`
pop  ebp
ret
```

On x64 the prologue/epilogue vary and compilers often use `RBP` less frequently (and pass args in registers). [Microsoft for Developers+1](https://devblogs.microsoft.com/oldnewthing/20040116-00/?p=41023)
