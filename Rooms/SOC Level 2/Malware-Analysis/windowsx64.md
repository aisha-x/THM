# TryHackMe: Windows x64 Assembly room summary

- Room URL: https://tryhackme.com/room/win64assembly
- Next Room: https://tryhackme.com/room/windowsreversingintro

  
# **Task 1: Introduction**

This course is the first in a series about **reverse engineering Windows software**, focusing on understanding how executables work. Future lessons will involve practical analysis and progressively harder challenges.

### **What Is Reverse Engineering?**

Reverse engineering means **starting from the result and figuring out how it was made**.

In cybersecurity, this helps identify **vulnerabilities** or weak logic in a program.

It‚Äôs about understanding how software works ‚Äî not just what it does ‚Äî often by studying compiled code.

**Goal:** Find mistakes, exploit flaws, and understand hidden processes (like encryption logic or server communications).

### **Why It‚Äôs Challenging**

- Computers prioritize **speed, not readability**.
- High-level code (like C/C++) is converted by compilers into **complex assembly** optimized for performance, not human understanding.
- Reverse engineers must learn to **‚Äúthink like the compiler.‚Äù**

It‚Äôs a **long and self-guided journey** ‚Äî full of confusion, research, and experimentation ‚Äî but highly rewarding.

### **Tools Commonly Used**

- **x64dbg** ‚Äì Debugger for analyzing program behavior.
- **Ghidra** ‚Äì Decompiler for understanding binary logic.
- **SysInternals Suite** ‚Äì System monitoring and process inspection tools.

---

### **Recommended Knowledge**

1. **Computer Science fundamentals** (how software and memory work).
2. **C/C++ basics** ‚Äî understanding low-level logic helps interpret compiled code.
3. **Assembly language** ‚Äî especially Intel syntax, common in Windows environments.

# Task 2: Number Systems

Computers and humans use different **number systems** (or ‚Äúbases‚Äù) to represent values.

A **base** defines how many unique digits a system uses before ‚Äúrolling over‚Äù to the next position.

### **Base 10 (Decimal System)**

- Used by humans every day.
- Digits: **0‚Äì9**
- Each digit‚Äôs position represents powers of 10.
    
    Example:
    
    ```
    243 (base 10) = (2 √ó 10¬≤) + (4 √ó 10¬π) + (3 √ó 10‚Å∞)
                  = 200 + 40 + 3 = 243
    ```
    
- **Notation:** 12 or 12d

---

### **Base 7**

- Digits: **0‚Äì6**
- Each position represents powers of 7.
    
    Example:
    
    ```
    243 (base 7) = (2 √ó 7¬≤) + (4 √ó 7¬π) + (3 √ó 7‚Å∞)
                 = 98 + 28 + 3 = 129 (base 10)
    ```
    
- Converting **9 (base 10)** to base 7:
    
    ```
    9 = (1 √ó 7¬π) + (2 √ó 7‚Å∞) = 12 (base 7)
    ```
    
- **Notation:** 12‚Çá or 12(base7)

---

### **Base 2 (Binary System)**

- Used by computers.
- Digits: **0 and 1 only**
- Each position represents powers of 2.
    
    Example:
    
    ```
    0b1010 = (1 √ó 2¬≥) + (0 √ó 2¬≤) + (1 √ó 2¬π) + (0 √ó 2‚Å∞)
           = 8 + 0 + 2 + 0 = 10 (decimal)
    ```
    
- Common values to know:
    - 2¬π‚Å∞ = 1024
    - 2‚Åπ = 512
    - 2‚Å∏ = 256
    - 2‚Å∑ = 128
- **Notation:** 0b0110 or 110b

---

### **Base 16 (Hexadecimal System)**

- Used heavily in programming and computing.
- Digits: **0‚Äì9, A‚ÄìF**
    
    (A=10, B=11, C=12, D=13, E=14, F=15)
    
- Each position represents powers of 16.
    
    Example:
    
    ```
    0x4A = (4 √ó 16¬π) + (10 √ó 16‚Å∞)
          = 64 + 10 = 74 (decimal)
    ```
    
- **Notation:** 0xFF, FFh, or \xFF (in byte notation)
    - Two hexadecimal digits = 1 byte
        
        Example: `\x12\x45\x21` ‚Üí 3 bytes
        

---

### **Prefixes and Suffixes Summary**

| Base | System Name | Example | Prefix | Suffix |
| --- | --- | --- | --- | --- |
| 10 | Decimal | 12 or 12d | ‚Äì | d |
| 2 | Binary | 0b1010 or 1010b | 0b | b |
| 16 | Hexadecimal | 0x1F or 1Fh | 0x / \x | h |
| 7 | Base 7 | 12‚Çá or 12(base7) | ‚Äì | (base7) |

# Task 3: Bits and Bytes

### Basic Units of Data

Computers store and process data in **bits** and **bytes**.

| Unit | Size | Description |
| --- | --- | --- |
| **Bit** | 1 binary digit | Can be **0** or **1** |
| **Nibble** | 4 bits | Half a byte |
| **Byte** | 8 bits | Basic unit of storage |
| **Word** | 2 bytes (16 bits) | Common CPU data size |
| **Double Word (DWORD)** | 4 bytes (32 bits) | Twice a word |
| **Quad Word (QWORD)** | 8 bytes (64 bits) | Four times a word |

### ‚ûï‚ûñ Signed vs Unsigned Numbers

- **Unsigned** ‚Üí Only positive values (no sign bit used).
- **Signed** ‚Üí Can represent both positive and negative values (one bit is reserved as a **sign bit**).
    - `0` = positive
    - `1` = negative

### Common Data Type Sizes

| Type | Typical Size | Description / Range |
| --- | --- | --- |
| **Char** | 1 byte (8 bits) | Holds a character |
| **Bool** | 1 byte | True (1) or False (0), though it only needs 1 bit ‚Äî a full byte is used for memory alignment |
| **Int (Signed)** | 16-bit, 32-bit, or 64-bit | One bit for sign, rest for value |

### **Signed Integer Ranges**

| Bit Size | Range |
| --- | --- |
| 16-bit (2^15) | ‚àí32,768 ‚Üí +32,767 |
| 32-bit (2^31) | ‚àí2,147,483,648 ‚Üí +2,147,483,647 |
| 64-bit (2 ^63) | ‚àí9,223,372,036,854,775,808 ‚Üí +9,223,372,036,854,775,807 |

### **Unsigned Integer Ranges**

- Start at **0** and go up to **twice the positive limit** of the signed version.
    - Example: Unsigned 32-bit ‚Üí 0 to **4,294,967,295**

### Why 16-bit = 32,767 (for signed integers)

1. **16 bits** ‚Üí 2^16=65,536 total combinations.
2. In **signed** integers, one bit is used for the sign ‚Üí **15 bits** left for the numeric value.
3. 2^15=32,768 values can represent:
    - Negative numbers: ‚àí32,768 ‚Üí ‚àí1
    - Zero: 0
    - Positive numbers: 1 ‚Üí 32,767

So the range is **‚àí32,768 to +32,767**, still totaling 65,536 unique values.

---

### Offsets

- **Offset** = the distance (in bytes) from a variable‚Äôs **base address** (its starting memory location).
- If each piece of data takes 2 bytes, the offset increases by 0x2 for each next element.

Example:

| Value | Offset |
| --- | --- |
| 1 | BaseAddress + 0x0 |
| 2 | BaseAddress + 0x2 |
| 3 | BaseAddress + 0x4 |
| 4 | BaseAddress + 0x6 |

So, **BaseAddress + 0x2** means ‚Äúthe data that is 2 bytes after the start.‚Äù

---

### Learn More

üîó [C Data Types ‚Äî Tutorialspoint](https://www.tutorialspoint.com/cprogramming/c_data_types.htm)

# Task 4 Binary Operation

Computers perform operations using **binary logic** (1s and 0s).

These logical operations form the foundation of all computation.

### True and False

- **False = 0**
- **True = any non-zero value** (e.g., 1, 100, memory address, character, etc.)
- In binary:
    
    ```
    0 ‚Üí False
    1 ‚Üí True
    ```
    

### Logical Operations

### **1. NOT ( ! )**

- Flips the bit (inverts it).
    
    ```
    NOT 1 = 0
    NOT 0 = 1
    ```
    

### **2. AND ( & )**

- Returns **1** only if **both bits** are 1.
    
    
    | A | B | A AND B |
    | --- | --- | --- |
    | 0 | 0 | 0 |
    | 0 | 1 | 0 |
    | 1 | 0 | 0 |
    | 1 | 1 | 1 |

### **3. OR ( | )**

- Returns **1** if **either bit** is 1.
    
    
    | A | B | A OR B |
    | --- | --- | --- |
    | 0 | 0 | 0 |
    | 0 | 1 | 1 |
    | 1 | 0 | 1 |
    | 1 | 1 | 1 |

### **4. XOR ( ^ )**

- Returns **1** only if the bits are **different**.
    
    
    | A | B | A XOR B |
    | --- | --- | --- |
    | 0 | 0 | 0 |
    | 0 | 1 | 1 |
    | 1 | 0 | 1 |
    | 1 | 1 | 0 |

### Inverse Operations

These are the **NOT versions** of other logic operations:

| Operation | Meaning | Example | Description |
| --- | --- | --- | --- |
| **NAND** | NOT AND | 1 NAND 1 = 0 | Performs AND, then inverts result |
| **NOR** | NOT OR | 1 NOR 0 = 0 | Performs OR, then inverts result |

So:

```
NAND = NOT(AND)
NOR = NOT(OR)
```

# Task 5: Registers

## Introduction to Assembly Language (Intel Syntax)

Intel vs AT&T Syntax

- There are two main assembly syntaxes:
    - **Intel syntax** ‚Üí used by **Windows** (we‚Äôll focus on this).
    - **AT&T syntax** ‚Üí more common on **Linux** systems.

## What Is Assembly?

Assembly is the **low-level language** that directly communicates with the CPU.

- High-level languages (like C or Python) are compiled into assembly instructions.
- These instructions tell the CPU **exactly** what to do ‚Äî move data, perform calculations, compare values, and control program flow.

### Assembly vs C (Example)

C code:

```c
if (x == 4) {
    func1();
} else {
    return;
}
```

Equivalent pseudo-assembly:

```nasm
mov RAX, x       ; move x into RAX register
cmp RAX, 4       ; compare RAX with 4
jne 5            ; jump to line 5 (return) if not equal
call func1       ; call the function if equal
ret              ; return
```

In short: Assembly instructions mirror logic operations at the CPU level.

## Registers Overview

Registers are **tiny, high-speed storage locations** inside the CPU used to hold data temporarily.

- Much faster than accessing data in memory (RAM).
- Limited in number and size.
- Typically 64 bits (8 bytes) on modern CPUs.

### General-Purpose Registers (GPRs)

These are used for most operations: 

| Register | Common Name | Usual Purpose |
| --- | --- | --- |
| **RAX** | Accumulator | Holds function return values |
| **RBX** | Base register | General-purpose, sometimes used for memory addressing |
| **RCX** | Counter | Loop counters |
| **RDX** | Data | Used in I/O operations and calculations |
| **RSI** | Source Index | Source pointer (for string or data operations) |
| **RDI** | Destination Index | Destination pointer |
| **RSP** | Stack Pointer | Points to the top of the stack |
| **RBP** | Base Pointer | Points to the base (bottom) of the stack frame |

*More info:* https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture

**Important:**

- You can technically use any register for any purpose.
- But **RSP** and **RBP** are critical for managing the **stack**, so you should not modify them carelessly.

### Instruction Pointer (RIP)

- **RIP (Instruction Pointer)** holds the **address of the next instruction** to execute.
- You **cannot directly modify** RIP ‚Äî only special instructions like `ret` or jumps (`jmp`) change it.

## Register Breakdown (Sub-registers)

Each register can be accessed in smaller parts:

| 64-bit | 32-bit | 16-bit | 8-bit (high) | 8-bit (low) |
| --- | --- | --- | --- | --- |
| RAX | EAX | AX | AH | AL |

Example:

If `RAX = 0x0123456789ABCDEF`, then:

```
RAX = 0x0123456789ABCDEF
EAX = 0x89ABCDEF
AX  = 0xCDEF
AH  = 0xCD
AL  = 0xEF
```

**Prefixes:**

- `R` = 64-bit (Register)
- `E` = 32-bit (Extended)
- `A`, `B`, `C`, `D` = historical naming conventions from older processors

## Data Types and Specialized Registers

Different data types are stored in **different kinds of registers**:

| Data Type | Register Type | Example Registers | Size |
| --- | --- | --- | --- |
| **Integer / Pointer / Boolean / Char** | General Purpose | RAX, RBX, RCX... | 64-bit |
| **Floating Point / SIMD (vectors)** | Special FP registers | XMM0‚ÄìXMM15, YMM0‚ÄìYMM15 | 128-bit or 256-bit |

**SIMD Registers:**

- **XMM** = 128 bits ‚Üí holds multiple 32-bit or 64-bit numbers.
- **YMM** = 256 bits ‚Üí holds twice as many as XMM.
    
    Used for **vectorized** (parallel) operations in floating-point math.
    

---

## ‚ûï Extra Registers (R8‚ÄìR15)

When 64-bit CPUs were introduced (x86_64 architecture), more general-purpose registers were added to give programmers extra storage and flexibility.

| Register | Bit Width | Smaller Parts |
| --- | --- | --- |
| **R8 ‚Äì R15** | 64-bit each | Have smaller versions just like RAX, etc. |

Each of these has **sub-registers** for partial access:

| Register | 32-bit | 16-bit | 8-bit |
| --- | --- | --- | --- |
| R8 | R8D | R8W | R8B |
| R9 | R9D | R9W | R9B |
| R10 | R10D | R10W | R10B |
| ... | ... | ... | ... |
| R15 | R15D | R15W | R15B |

**Naming pattern:**

- `D` = Double word (32 bits)
- `W` = Word (16 bits)
- `B` = Byte (8 bits)

**Example:**

```
R8  ‚Üí full 64 bits (8 bytes)
R8D ‚Üí lower 32 bits
R8W ‚Üí lower 16 bits
R8B ‚Üí lower 8 bits
```

**Why they exist:**

Older 32-bit CPUs only had 8 general-purpose registers (RAX‚ÄìRDI).

64-bit CPUs added **R8‚ÄìR15** to increase the total to 16 GPRs, improving performance and allowing more variables to stay in registers instead of slow memory.

### Summary Table

| Category | Registers | Description |
| --- | --- | --- |
| **General Purpose** | RAX‚ÄìRDI | Main working registers |
| **Stack Management** | RSP, RBP | Handle stack frame |
| **Instruction Pointer** | RIP | Tracks next instruction |
| **Extra (x64)** | R8‚ÄìR15 | Additional 64-bit registers |
| **Floating Point / SIMD** | XMM0‚Äì15, YMM0‚Äì15 | Hold vectorized float/double data |

# Task 6: Instruction

### **Assembly Syntax Overview**

There are two main assembly syntaxes:

- **Intel syntax** ‚Üí Used mostly in Windows (clearer and simpler).
- **AT&T syntax** ‚Üí Common in Linux.

### **Instruction Basics**

- Assembly code follows the format:
    
    ```
    instruction <destination>, <source>
    ```
    
    Example:
    
    `mov RAX, 5` ‚Üí Moves the immediate value 5 into the register RAX.
    
- **Operands can be:**
    - **Immediate:** Constant values (e.g., `5`, `12`)
    - **Register:** CPU storage units (e.g., `RAX`, `RBX`)
    - **Memory:** Addresses in RAM (e.g., `[0x7FFF842B]`)
- **Comments** are written with `;` (semicolon).

### **Common Instructions**

### Data Movement

- **MOV** ‚Äì Copies data into a destination (`mov RAX, 5`)
- **LEA** ‚Äì Loads an *address* (not the value) ‚Üí `lea RAX, [num]`
- **PUSH / POP** ‚Äì Save and restore register values on the stack

### Arithmetic

- **INC / DEC** ‚Äì Increment or decrement by 1
- **ADD / SUB** ‚Äì Add or subtract values (`add RAX, RBX`)
- **MUL / IMUL** ‚Äì Multiply RAX by another register (result in RDX:RAX)
- **DIV / IDIV** ‚Äì Divide RAX by another register (result in RAX)

### Flow Control

- **RET** ‚Äì Return from a function (often returns value in `RAX`)
- **CMP** ‚Äì Compare two values and set CPU *flags*
- **JCC (Conditional Jumps)** ‚Äì Jump if condition met (e.g., `JNE`, `JLE`, `JG`, etc.)
- **NOP** ‚Äì ‚ÄúNo operation,‚Äù does nothing (used for code alignment)

### **Example: Translating C to Assembly**

C Code:

```c
if (x == 4) func1();
else return;
```

Equivalent Assembly:

```nasm
mov RAX, x
cmp RAX, 4
jne 5   ; Jump to return if not equal
call func1
ret
```

### **Pointers and Memory**

- **Square brackets `[ ]`** ‚Üí *Dereference* memory (get value at address).
- **LEA** ‚Üí Load *address* (not value).

Example:

```nasm
lea RAX, [var]   ; RAX = address of var
mov [RAX], 12    ; Set value at that address to 12
```

### **Zero Extension**

When writing to a smaller register (like EAX instead of RAX), upper bits may or may not be cleared:

- Writing to **EAX** clears upper 32 bits of **RAX** (zero-extends).
- Writing to **AX**, **AH**, or **AL** does **not** zero-extend.
- To force zero-extension: use **MOVZX**.

### **Jumps and Comparisons**

There are two sets of jump instructions:

- **Unsigned:** `JA`, `JB`, `JAE`, `JBE`
- **Signed:** `JG`, `JL`, `JGE`, `JLE`
    
    ‚Üí Think: *‚ÄúGreater/Less‚Äù = Signed; ‚ÄúAbove/Below‚Äù = Unsigned*
    

Example:

```nasm
cmp RAX, RBX
jg label   ; Jump if greater (signed)
```

### **Compiler Optimization Insight**

Compilers often flip conditions for efficiency:

Instead of:

```cpp
if(x == 4){
    func1();
}
else{
    return;
}
```

You‚Äôll see:

```cpp
if(x != 4){
    goto __exit;
}
func1();
__exit:
return;
```

This avoids unnecessary branches for speed.

# Task 7: Flags

Flags are bits in the **EFLAGS/RFLAGS register** that reflect the outcome of arithmetic or logical operations. They help the CPU make decisions (e.g., whether to jump, continue, or compare).

### **Key Status Flags**

- **ZF (Zero Flag):** Set when the result is `0`.
- **CF (Carry Flag):** Set when an **unsigned** operation carries or borrows beyond the register.
- **OF (Overflow Flag):** Set when a **signed** operation‚Äôs result is too large for the register.
- **SF (Sign Flag):** Set when the result is negative.
- **AF (Adjust Flag):** Used for Binary Coded Decimal (BCD) operations.
- **PF (Parity Flag):** Set if the last byte has an **even number of 1s**.
- **TF (Trap Flag):** Enables single-step debugging.

For a full list of flags see:¬†https://www.tech-recipes.com/rx/1239/assembly-flags/

### **Examples**

**1. Comparison (`cmp`)**

```nasm
mov RAX, 4
cmp RAX, 4
jne 5
call func1
ret
```

- `cmp RAX, 4` subtracts 4 from RAX.
- Result = 0 ‚Üí `ZF = 1`, meaning values are equal, so no jump occurs.

**2. Subtraction (signed)**

```nasm
mov RAX, 2
sub RAX, 8
```

- Result = -6 ‚Üí `SF = 1` (negative result).

**3. Addition (overflow)**

```nasm
mov AL, 75
add AL, 60
```

- Result = 135 (too large for 8-bit signed) ‚Üí wraps to -121
- `OF = 1` (overflow), `SF = 1` (negative result).

# Task 8: Calling Convention

**What is a calling convention?**
A calling convention is a set of rules that say:
‚Ä¢ **How** a function (you call this the *callee*) receives its inputs (parameters) and returns a result.
‚Ä¢ **Where** the inputs go (registers vs stack).
‚Ä¢ **Who** is responsible for cleaning up after a function call (caller or callee).
These rules ensure that when you call functions (including those in libraries) things behave predictably. [Wikipedia+1](https://en.wikipedia.org/wiki/Calling_convention?utm_source=chatgpt.com)
****

**The Windows x64 calling convention ‚Äî key rules**
Below are the major rules used on 64-bit Windows (often called the Microsoft x64 calling convention). [Microsoft Learn+1](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170&utm_source=chatgpt.com)
**1. First four parameters go in registers**

- The first 4 integer or pointer parameters are passed in these registers **in left-to-right order**:
`RCX`, then `RDX`, then `R8`, then `R9`. [Ired Team+1](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/windows-x64-calling-convention-stack-frame?utm_source=chatgpt.com)
- If parameters are floating-point (e.g., `double`, `float`), they use the SSE registers: `XMM0`, `XMM1`, `XMM2`, `XMM3` in the same left-to-right order. [ACCU](https://accu.org/journals/overload/22/120/orr_1897/?utm_source=chatgpt.com)
- Example: `func(10, 20, 30, 40)` means
    - `10` ‚Üí `RCX`
    - `20` ‚Üí `RDX`
    - `30` ‚Üí `R8`
    - `40` ‚Üí `R9`
1. **Additional parameters beyond four ‚Üí stack**
    - If your function has **more than four parameters**, the 5th, 6th, etc., are placed on the stack. [Ired Team+1](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/windows-x64-calling-convention-stack-frame?utm_source=chatgpt.com)
    - They are pushed on the stack from **right to left**, so the 5th parameter ends up at the lowest address among those stack parameters.
2. **‚ÄúShadow space‚Äù (home space) reservation**
    - Even if you pass fewer than four parameters (or even none), you still **reserve space on the stack** for the first four register parameters. On Windows x64 this is typically **32 bytes** (4 √ó 8 bytes) called the "shadow space". [Microsoft for Developers+1](https://devblogs.microsoft.com/oldnewthing/20160623-00/?p=93735&utm_source=chatgpt.com)
    - This space exists so the callee function has guaranteed room to spill (store) those register-passed parameters if it needs to.
3. **Return value rules**
    - When a function returns an integer, pointer, or similar, the result is put in `RAX`. [Microsoft Learn](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170&utm_source=chatgpt.com)
    - If the function returns a floating-point value (e.g., `double`), it comes back in `XMM0`. [ACCU](https://accu.org/journals/overload/22/120/orr_1897/?utm_source=chatgpt.com)
4. **Register usage: volatile vs non-volatile**
    - Some registers are considered **volatile (caller-saved)** ‚Äî the caller must assume the callee may overwrite them. These include: `RAX`, `RCX`, `RDX`, `R8`, `R9`, `R10`, `R11` (and some XMM registers) on Windows. [Stack Overflow](https://stackoverflow.com/questions/53290932/what-are-r10-r15-registers-used-for-in-the-windows-x64-calling-convention?utm_source=chatgpt.com)
    - Others are **non-volatile (callee-saved)** ‚Äî if the callee uses them, it must save & restore them so the caller sees them unchanged. These include: `RBX`, `RBP`, `RDI`, `RSI`, `R12`, `R13`, `R14`, `R15` (and some XMM registers). [Stack Overflow](https://stackoverflow.com/questions/20889957/what-registers-need-preserved-in-microsoft-x86-64-calling-convention?utm_source=chatgpt.com)
5. **Stack alignment**
    - On Windows x64, before calling a function, the stack pointer (`RSP`) must be aligned to a 16-byte boundary. The convention ensures this for optimal performance. [Reddit](https://www.reddit.com/r/Compilers/comments/1hlyvzm/windows_x86_64_calling_convention/?utm_source=chatgpt.com)
    **Example scenario**
    Let‚Äôs walk through a simple example using a function with 6 integer parameters:
    
    `void myFunc(int a, int b, int c, int d, int e, int f);`
    When calling `myFunc(1,2,3,4,5,6)`, under Windows x64:
        - `a = 1` ‚Üí `RCX = 1`
        - `b = 2` ‚Üí `RDX = 2`
        - `c = 3` ‚Üí `R8 = 3`
        - `d = 4` ‚Üí `R9 = 4`
        - `e = 5` ‚Üí push 5 onto stack (this is the 5th parameter)
        - `f = 6` ‚Üí push 6 onto stack (6th parameter)
        - Caller must reserve 32 bytes (shadow space) before the call (even though we use registers for first four)
        - Then call happens. Inside `myFunc`, it accesses the first four parameters via `RCX`, `RDX`, `R8`, `R9`, and for `e`/`f` it finds them on the stack at known offsets.
        - After `myFunc` returns, the caller cleans up any stack space it used.
    
    **Why this matters**
    Understanding these rules helps you when:
    ‚Ä¢ You look at disassembled code and want to figure out what each register or stack location means.
    ‚Ä¢ You write assembly or reverse-engineer functions ‚Äî you know where to look for parameters and where the return value will be.
    ‚Ä¢ You debug or inspect function calls ‚Äî you can track how parameters are passed and returned.
    

# Task 9: Memory Layout

Every program that runs on your computer needs **memory** ‚Äî to store:

- Code
- Variables
- Functions
- Temporary data
- Dynamically allocated objects

The operating system organizes memory into **segments (sections)** so everything has a specific place.

## 1. Memory Segments Overview

When a program runs, its memory looks roughly like this:

```
+-----------------------------+  High memory addresses
|        Stack                |  (grows downward)
|-----------------------------|
|        Heap                 |  (grows upward)
|-----------------------------|
|        .bss (zero data)     |
|        .data (init data)    |
|        .text (code)         |
+-----------------------------+  Low memory addresses

```

### The Main Sections

| Segment | Purpose | Example |
| --- | --- | --- |
| **.text** | Contains program **code** (instructions you wrote). | Your compiled functions, loops, etc. |
| **.data** | Stores **initialized global/static variables**. | `int a = 5;` |
| **.bss** | Stores **uninitialized** or **zero-initialized global/static variables**. | `int b;` or `int c = 0;` |
| **Heap** | Stores **dynamic memory** ‚Äî created at runtime with `malloc()`, `new`, etc. | `int* ptr = malloc(10);` |
| **Stack** | Stores **local variables**, **function parameters**, **return addresses**, etc. | Local variable inside a function |

## 2. The Stack ‚Äî Last In, First Out (LIFO)

Think of the **stack** like a stack of plates:

- You put new data on top (**push**).
- You remove the top plate first (**pop**).

### Stack Characteristics

- Used for **local variables** and **function calls**.
- Grows **downward** (toward lower memory addresses).
- Accessed using two key **registers**:
    - **RSP** (Stack Pointer): points to the top of the stack.
    - **RBP** (Base Pointer): marks the base of the current function‚Äôs frame.

### Example

When a function is called:

1. The **return address** (where to go back) is pushed.
2. Function parameters may be stored.
3. Space for local variables is reserved.

When the function ends:

- Everything it used is **popped** off, restoring the previous stack state.

### Stack Directions

If we visualize addresses (lower numbers on top):

```
Low Addresses
     ‚Üë
     | Push new item (stack grows upward)
     | Pop removes top (stack shrinks downward)
High Addresses
```

But in **real memory**, the stack **grows downward** (toward smaller addresses).

That‚Äôs just how the CPU stack works ‚Äî a little counterintuitive at first!

## 3. The Heap ‚Äî Dynamic Memory

- Used for **data with unknown size or lifetime** (e.g., user input, large buffers).
- Managed manually using functions like `malloc()`, `calloc()`, `free()` (in C) or `new`/`delete` (in C++).
- Grows **upward** (toward higher addresses).
- Slightly slower to access than the stack because it‚Äôs managed by the OS.

### Example

```c
int* arr = malloc(100 * sizeof(int));
```

- Memory for 100 integers is allocated on the heap.
- The **pointer `arr`** (which points to the heap) is stored on the **stack**.

## 4. Program Image, PEB, and TEB (Windows Specific)

When a program runs on Windows, it‚Äôs loaded as a **Portable Executable (PE)** file in memory.

### Important structures:

- **PEB (Process Environment Block):**
    
    Stores info about the whole process (e.g., loaded DLLs, ‚Äúbeing debugged‚Äù flag, etc.).
    
    [Microsoft Docs: PEB](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)
    
- **TEB (Thread Environment Block):**
    
    Stores info about each **thread** (like stack limits, thread ID, etc.).
    

You usually don‚Äôt need these unless you‚Äôre doing **reverse engineering** or **low-level debugging**.

## 5. Stack Frames (Per Function)

Each **function call** gets its own **stack frame** containing:

- Local variables
- Function parameters
- Saved base pointer (RBP)
- Return address (where to continue after returning)

### Example

```c
int Square(int x) {
    return x * x;
}

int main() {
    int num = 5;
    Square(num);
}
```

When `main()` calls `Square()`:

1. `main`‚Äôs frame is created first.
2. When `Square()` is called:
    - Return address and old `RBP` are pushed.
    - New `RBP` is set.
    - Space for `x` is created.
3. When `Square()` finishes:
    - Stack is restored (old `RBP` and return address popped).
    - CPU continues at the instruction **after** the call.

### The Return Address

The return address is the **next instruction** after the function call:

```nasm
mov RAX, 15
call func
mov RBX, 23   ; <-- this is the return address
```

When `func` ends, execution continues at `mov RBX, 23`.

## 6. Endianness ‚Äî Byte Order in Memory

Endianness decides how multi-byte data (like integers) are stored.

| Type | Description | Example (0xDEADBEEF) |
| --- | --- | --- |
| **Big Endian** | Most significant byte stored first | `DE AD BE EF` |
| **Little Endian** | Least significant byte stored first | `EF BE AD DE` |

 **Windows, Intel, and AMD CPUs use Little Endian.**

üîó [Good video explanation](https://www.youtube.com/watch?v=NcaiHcBvDR4)

## 7. How Data Is Stored on the Stack

Memory space is **allocated downward** (high ‚Üí low addresses),

but data itself is **written upward** (low ‚Üí high addresses).

### Example

```c
int a = 1;
int b = 2;
int arr[2] = {3, 4};
```

Memory layout might look like:

| Address | Data | Variable |
| --- | --- | --- |
| 0x1000 | 1 | a |
| 0x0FFC | 2 | b |
| 0x0FF8 | 3 | arr[0] |
| 0x0FF4 | 4 | arr[1] |

If you accidentally overflow (e.g., `arr[3] = 5`),

you overwrite whatever‚Äôs below ‚Äî which can cause **stack corruption or crashes**.

## 8. RSP & RBP on x64

In older (x86) code:

- **RBP** was always used as a fixed reference for the function‚Äôs frame.
- **RSP** pointed to the current top of the stack.

In modern (x64) compilers:

- **RSP** alone is often used for local variables and parameters.
- **RBP** may be used for general-purpose work (to optimize performance).

This is normal in optimized builds ‚Äî so don‚Äôt be confused if `RBP` isn‚Äôt used like the classic base pointer.

---

## Summary

| Concept | Description |
| --- | --- |
| **.text** | Stores program code (functions) |
| **.data / .bss** | Store global/static variables |
| **Heap** | Dynamic memory (grows upward) |
| **Stack** | Local variables & function calls (grows downward) |
| **PEB / TEB** | Windows structures for process and thread info |
| **Stack Frame** | Function‚Äôs local storage (locals, params, return addr) |
| **Endianness** | Byte order in memory (Windows uses Little Endian) |
| **RSP / RBP** | Stack management registers |

# References

- https://github.com/ReversingID/Awesome-Reversing/tree/master
- http://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html
- https://developer.amd.com/resources/developer-guides-manuals/
- https://docs.microsoft.com/en-us/
