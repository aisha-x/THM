# TryHackMe: Static Analysis

Room url: https://tryhackme.com/room/staticanalysis1

# **Task 1: Introduction**

We will start analyzing malware starting from this room.

**Pre-requisites:**

Before starting this room, it is recommended that you complete the following rooms.

- [Intro to Malware Analysis](http://tryhackme.com/jr/intromalwareanalysis)
- x86 Assembly Crash Course
- x86 Architecture Overview

**Learning Objectives**

The first step in analyzing malware is generally to look at its properties without running it. This type of analysis is called static analysis because the malware is static and is not running. We will cover basic static analysis in this room. In particular, we will cover the following topics.

- Lab setup for malware analysis
- Searching for strings in a malware
- Fingerprinting malware through hashes
- Signature-based detection mechanisms
- Extracting useful information from the PE header

So, without further ado, let’s move on to the next task to learn about setting up a malware analysis lab.

# **Task 2: Virtual Machines for Malware Analysis**

**Purpose:**

Virtual Machines (VMs) allow malware analysts to safely study malicious software by isolating it from the host system. Analysts can take **snapshots** of the VM to save its clean state and **revert** to it after each analysis, ensuring a fresh, uncontaminated environment every time.

**Typical Workflow:**

1. Create a new VM and install an operating system.
2. Install necessary malware analysis tools.
3. Take a snapshot of the clean setup.
4. Run and analyze malware samples within the VM.
5. Revert to the clean snapshot after analysis.

This approach avoids tool reinstallation and leftover malware traces.

**Common Malware Analysis VMs:**

- **FLARE VM:**
    - Windows-based (Windows 7/10) by **Mandiant (FireEye)**.
    - Contains popular malware analysis tools and is customizable.
    - Suitable for **dynamic analysis of Windows malware**.
    - Documentation available on GitHub and the Mandiant blog.
- **REMnux:**
    - Linux-based, created by **Lenny Zeltser** in 2010.
    - Includes many pre-installed reverse engineering tools.
    - Best for **static analysis** or Linux malware (not for dynamic Windows malware).
    - Documentation available on GitHub and the REMnux website.

Both FLARE VM and REMnux simplify setup and ensure safe, efficient malware analysis environments.

Follow this tutorial to install and configure Flare-VM → https://aisha-x.github.io/posts/SettingupMalwareAnalysisLab/

# Task 3: String search

**What a string search does**

A string search scans a binary’s raw bytes for sequences of ASCII/Unicode characters terminated by a null byte and reports those as "strings." Many matches are *false positives* (addresses, instructions, garbage), so the analyst must pick useful results and ignore noise.

**What to look for (useful IOCs):**

- Windows APIs / function names (e.g., `CreateProcess`, `InternetOpen`, `SetWindowsHook`) — hint at functionality.
- IP addresses, URLs, domains — possible C2 or network IOCs (e.g., WannaCry kill-switch domain).
- Miscellaneous readable data — Bitcoin addresses, message-box text, config-like strings.

**Basic tools & usage:**

- Linux `strings` utility (dumps strings to file).
- Windows `strings.exe` (Sysinternals) on FLARE VM:
    
    ```
    C:\Users\Administrator\Desktop>strings <path to binary>
    ```
    
- GUI tools on FLARE VM: **CyberChef** (has a string-recovery recipe) and **PEstudio** (shows encoding, size, offset, hints, blacklist matches).

**PEstudio features:**

Lists strings with metadata (encoding, offset, size) and flags known/blacklisted API strings to aid triage.

<img width="1080" height="559" alt="image" src="https://github.com/user-attachments/assets/ffb2f63c-4ecf-4acc-85ab-43772d7b3f5c" />

**Obfuscated strings & FLOSS:**

- Malware often obfuscates strings, making basic string searches ineffective.
- **FLOSS** (FireEye Labs Obfuscated String Solver) extracts deobfuscated strings that ordinary searches miss. Example usage on FLARE VM:
    
    ```
    C:\Users\Administrator\Desktop>floss -h
    C:\Users\Administrator\Desktop>floss --no-static-strings <path to binary>
    ```
    
    (May take time and produce intermediate-looking errors before results.)
    

**Quick analyst workflow for strings:**

1. Run basic `strings` or strings.exe.
2. Inspect outputs for APIs, network indicators, readable config/text.
3. Use PEstudio/CyberChef for richer context.
4. If few results or likely obfuscation, run FLOSS to recover hidden strings.
5. Ignore garbage/FPs; focus on actionable IOCs.

# **Task 4: Fingerprinting Malware**

**Purpose:**

In malware analysis, unique identification of samples is crucial. Since file names can be easily changed, **hash functions** are used to generate unique digital fingerprints based on file content.

**How Hashing Works:**

- A **hash function** converts data of any size into a fixed-length string (hash).
- The hash changes completely if even a single byte in the file changes.
- It’s **irreversible** — you cannot recover the file from its hash.
- File name changes do **not** affect the hash.
- Hashes are used for **file identification**, **IOC tracking**, and **repository searches**.

**Common Hash Types:**

- **MD5** → Fast but insecure (collision-prone)
- **SHA1** → More secure than MD5 but still collision-prone
- **SHA256** → Most secure and recommended for malware identification

### **Finding Similar Files Using Hashes**

Sometimes analysts need to find **related or similar** malware rather than identical files. Certain types of hashes help with this:

### **1. Imphash (Import Hash):**

- Based on the list and order of **imported functions/libraries (DLLs)** in a PE file.
- If two malware samples import the same libraries in the same order, they share the same **imphash**.
- Used to detect **malware variants** or samples from the **same threat family**.
- Tools like **PEstudio** can calculate the imphash.
- Example: Different SHA256 hashes but identical imphash → likely from the same malware family.

### **2. Fuzzy Hash / SSDEEP:**

- A **Context Triggered Piecewise Hash (CTPH)**.
- Divides a file into chunks and hashes each part → allows **partial similarity detection**.
- Two files with similar byte sequences will produce **partially matching hashes**.
- Tools: `ssdeep` utility (available on Desktop) or **CyberChef**.
- Example command:
    
    ```
    ssdeep -r -l -d <directory>
    ```
    
    - `r` → recursive scan
    - `l` → show relative file paths
    - `d` → compare and show matching files with **similarity percentage**

<img width="885" height="233" alt="image" src="https://github.com/user-attachments/assets/3c3f98de-c53d-4d74-9079-2e6b707c12cd" />

**Result:**

Files with higher match percentages are likely **variants of the same malware**.

### **Key Takeaways**

- **SHA256** → Unique identification (exact match).
- **Imphash** → Similar imports (same family).
- **SSDEEP** → Partially similar files (variant detection).
- Hashes are essential **Indicators of Compromise (IOCs)** used across malware repositories and investigations.

# **Task 5: Signature-Based Detection**

**What Are Signatures?**

A **signature** is a unique pattern (usually a sequence of bytes or text) used to identify specific content within a file.

In malware analysis, signatures help:

- Detect if a file is malicious.
- Identify malware families or behaviors.
- Recognize known malicious patterns in binaries.

### **1. Yara Rules**

**Overview:**

- Yara is a **signature-based pattern-matching tool**, often called the *Swiss Army knife* for malware researchers.
- It can detect **binary patterns**, **hex sequences**, and **text strings** within files.
- Widely used to identify malware families or detect known indicators.

**Key Points:**

- Open-source community Yara rules are available in public repositories.
- Some rules can produce **false positives**, so analysts should **check documentation** before relying on a match.
- A Yara match doesn’t always mean a file is malicious—it only means the pattern was found.

### **2. Proprietary Signatures (Antivirus Scans)**

**Overview:**

- Antivirus (AV) vendors create **commercial signatures** that are usually more refined and tested, reducing false positives (FPs).
- However, AV tools may still produce **false negatives (FNs)** when they miss certain malware.

**VirusTotal:**

- A free service that checks a file or hash against **60+ antivirus engines**.
- Safer practice: **search by hash (e.g., SHA256)** instead of uploading the actual file — to avoid leaking sensitive data or alerting attackers.
- Useful for quick verdicts and metadata on a sample.

### **3. Capa (by Mandiant)**

**Overview:**

- **Capa** is an open-source tool that identifies **capabilities** within a PE file using signature-based analysis.
- It detects behaviors such as file manipulation, network communication, process injection, etc.
- Results are mapped to the **MITRE ATT&CK** and **Malware Behavior Catalog (MBC)** frameworks.

**Usage Example:**

```
C:\Users\Administrator\Desktop>capa mal.exe
```

- Use `h` for help, or `v` / `vv` for verbose output (shows addresses of detected capabilities).
- Run against malware samples (e.g., `Desktop\mal\4`).
- Capa identifies features such as imported APIs, strings, mutexes, and even **obfuscated stack strings** (indicating that FLOSS might help).

<img width="683" height="722" alt="image" src="https://github.com/user-attachments/assets/f2c7e2ab-ed21-48d5-bf0e-7fe8b2b1fa89" />

### **Summary Table**

| Tool / Method | Purpose | Strengths | Limitations |
| --- | --- | --- | --- |
| **Yara Rules** | Detect patterns in files (hex, text, binary) | Flexible and community-driven | Needs careful rule validation; may give FPs |
| **Antivirus Signatures** | Commercial pattern detection | Reliable, low FPs | May miss new malware (FNs) |
| **VirusTotal** | Aggregates multiple AV scans | Multi-engine verification | Avoid uploading sensitive samples |
| **Capa** | Identifies malware **capabilities** via signatures | Maps to MITRE ATT&CK; behavior-focused | Slower analysis; doesn’t execute the sample |

**In short:**

Signature-based detection helps analysts quickly classify and understand malware using known patterns. Tools like **Yara**, **VirusTotal**, and **Capa** complement each other — with Yara for rule-based matching, VirusTotal for reputation checks, and Capa for behavior-level insight.

# **Task 6: Leveraging the PE Header**

**What is a PE file?**

- **PE (Portable Executable)** is the standard file format for Windows executables (`.exe`, `.dll`, `.sys`, etc.).
- It is called *portable* because it can run on any Windows system with the required dependencies.
- A PE file begins with structured metadata called the **PE header**, which tells the system how to load and execute the program.

---

### **Purpose of the PE Header**

The **PE header** stores critical information about the executable’s structure and behavior.

It helps malware analysts understand what the program does *without running it*.

**Key information found in the PE header:**

- **Linked Libraries (DLLs)** – external libraries the program depends on.
- **Imported Functions** – APIs the program calls from those libraries.
    - Example: If a PE imports `CreateProcessA`, it likely creates new processes.
    - These imports give analysts an **initial idea of the malware’s functionality**.

> Note: The PE header shows what functions are imported, not how or when they’re used — deeper analysis is needed for that.
> 

### **Analyzing PE Headers with PEStudio**

- **PEStudio**, available in FLARE VM, is a GUI tool for inspecting PE files.
- In PEStudio:
    - Select **“Libraries”** to view DLLs used by the file.
    - Select **“Functions”** to see imported APIs from those libraries.
- This helps analysts infer what the malware might do (e.g., network access, file manipulation, process creation).

<img width="832" height="431" alt="image" src="https://github.com/user-attachments/assets/1a634447-0097-43b5-8801-0250513a7690" />

### **Identifying Packed Executables**

**Why packing is used:**

Malware authors often use **packing** to hide malicious code from analysis.

A **packed executable** contains the original program compressed or encrypted inside a loader (shell) that unpacks it in memory at runtime.

**How packing affects analysis:**

- Makes **string searches**, **hash similarity**, and **signature detection** less effective.
- Can **evade antivirus** or static analysis tools.

**Detecting packed executables via the PE header:**

By checking attributes such as:

- **Number of sections** (unusually high or abnormal layout).
- **Section sizes** (tiny code section, large data section, etc.).
- **Section permissions** (e.g., executable + writable = suspicious).
    
    Analysts can often identify if a sample is packed and sometimes even guess **which packer** was used.
    

### **In Summary**

| Concept | Description | Tool / Indicator |
| --- | --- | --- |
| **PE Header** | Metadata that defines structure & behavior of a Windows executable | PEStudio |
| **Linked Libraries / Imports** | Show external functions & APIs used | Helps guess malware capabilities |
| **Packed Executable** | Malware wrapped in a protective shell to evade analysis | Detected via section irregularities in PE header |
