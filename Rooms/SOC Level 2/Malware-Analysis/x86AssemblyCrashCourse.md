# THM: x86 Assembly Crash Course summary

Room link: https://tryhackme.com/room/x86assemblycrashcourse

Other resource https://www.jaiminton.com/Tutorials/PracticalMalwareAnalysis/#

# Task-1: Introduction

- Assembly language is the lowest *human-readable* form of code (closest to machine/binary) and the highest reliable level when decompiling a binary.
- In malware reverse engineering, you often only have the compiled binary, not the original source code (C/C++).
- Disassemblers or decompilers convert binary to assembly, but much of the original information (variable names, function names, comments) is lost in compilation.
- Learning basic assembly is essential, because the assembly code is often the only insight you have into what a binary (especially malware) does.
- The topics you will learn include:
    - Opcodes & operands
    - General assembly instructions
    - Arithmetic and logical instructions
    - Conditionals
    - Branching instructions
    

# Task-2: Deep Dive & Explanation of Task 2: Opcodes and Operands

### 1. What is the actual machine code?

- A compiled binary is just a sequence of bits (0s and 1s).
- We group bits into bytes (8 bits) and often represent bytes in **hexadecimal** to make them more readable by humans.
- For example, the binary `1010 0101` is `A5` in hex, so you might see `0xA5`.

---

### 2. Opcodes: the “operation codes”

- An **opcode** (short for “operation code”) is a part of machine code that **tells the CPU what operation to perform** (e.g. add, move, jump). [Wikipedia+2Gist+2](https://en.wikipedia.org/wiki/Opcode)
- In a disassembler, the raw opcode bytes are translated into mnemonics (human-readable names) like `mov`, `add`, `jmp`, etc.
- For example, in x86, the opcode `0xB8` is commonly used for `mov eax, immediate_value`.
- The rest of the bytes in that instruction are used to encode the operands (which registers or memory or immediate values).
- Thus, an instruction in machine code is often: **[opcode] + [operand encoding]** [Gist+2Wikipedia+2](https://gist.github.com/mikesmullin/6259449)

---

### 3. Operands: what the operation acts upon

Operands are the “arguments” to the operation (the things the operation manipulates). There are three main kinds of operands:

| Type | Meaning | Example |
| --- | --- | --- |
| **Immediate operand** | A constant value encoded **directly** in the instruction itself | `mov eax, 0x5F` → here `0x5F` is an immediate |
| **Register operand** | A CPU register (like `eax`, `ebx`, `rax`, etc.) | `add eax, ebx` uses registers as operands |
| **Memory operand** | A reference to a location in memory (via an address) | `mov eax, [ebx]` means “load into eax from memory at address in ebx” |
- In some syntax, memory operands are shown in square brackets (e.g. `[eax]`), meaning “the memory at the address stored in `eax`.”
- You can mix them: e.g. `mov [eax], ebx` (store the value in `ebx` into memory pointed by `eax`), or `mov eax, 5` (move the immediate 5 into `eax`).
- Some instructions allow **at most one memory operand** (i.e., you cannot have both source and destination be memory in many architectures) — one operand may be memory, the other must be register or immediate. [Gist+1](https://gist.github.com/mikesmullin/6259449)

---

### 4. Endianness and how operand values are stored

One thing that often confuses learners is **how immediate operands (constants) are represented in memory**, especially in **little-endian** architectures (which is common in x86). THM original content mentioned this:

> In your example:
> 
> 
> `040000: b8 5f 00 00 00 mov eax, 0x5f`
> 
> Here, `b8` is the opcode (for `mov eax, …`) and the bytes `5f 00 00 00` are the immediate operand `0x5f`.
> 
> Because the CPU is little-endian, that 32-bit immediate is stored least significant byte first: `5f 00 00 00` (which, if read big-endian style, would look like `00 00 00 5f`).
> 

To simplify:

- **Little-endian**: the **least significant byte** is stored first (lowest address). This is how x86 and many modern architectures work. [Wikipedia+2Medium+2](https://en.wikipedia.org/wiki/X86_assembly_language)
- **Big-endian**: the **most significant byte** is stored first (lowest address). [Wikipedia+1](https://en.wikipedia.org/wiki/Endianness)
- Because of this, when you see `5f 00 00 00` in a disassembler, you must interpret it (by your architecture) as the value `0x0000005f` (i.e., 0x5F).

<img width="960" height="480" alt="image" src="https://github.com/user-attachments/assets/6e27eaae-3de6-4ea8-8fb4-addb8310004a" />

*Source: Wikipedia. Diagram demonstrating big- versus little-endianness*

---

### 5. Example walkthrough

Suppose we see this in disassembly:

```
0x100:  b8 5f 00 00 00    mov eax, 0x5f
```

- `0x100` is the memory address of the instruction.
- `b8` is the opcode byte for “move immediate into `eax`”.
- `5f 00 00 00` are the immediate operand bytes. Because the machine is **little-endian**, `5f` is the **least significant byte**, and so the value is `0x0000005f` (or just `0x5f`).
- The assembly mnemonic becomes: `mov eax, 0x5f`.

Another example with memory operand:

```
mov eax, [ebx]
```

- Here opcode might encode “move from memory” operation,
- `[ebx]` is a memory operand indicating the memory address stored in `ebx`,
- The CPU loads whatever 32-bit (or 64-bit) value is in memory at the address given by `ebx` into `eax`.

---

### 6. Why this is important for malware / reverse engineering

- When you analyze a binary, you don’t see `int x;` or `function foo()` or named variables. You see raw opcodes and operands.
- Being able to interpret instructions — knowing which opcodes correspond to what operation, and understanding how operands map to registers, memory or constants — is fundamental.
- Also, understanding how data is stored (endianness) helps you correctly interpret multi-byte constants and memory contents (for example, addresses, string pointers, numeric constants)
- Mistaking endian order can lead to misinterpreting values, which in malware analysis could lead to misunderstanding what the code is doing.

---

# Task-3: General Instructions in Assembly

In assembly language, **instructions** are the commands the CPU executes. Each instruction usually has a **mnemonic** (like `mov`, `add`, `shr`) and one or more **operands** (which might be registers, memory, or immediate values). The instruction tells the CPU *what to do* and *where to do it*.

Below are some of the most common instructions you’ll see when analyzing a binary (especially malware). Understanding these well will help you read what the program is doing at a low level.

---

### 1. `mov` — Move / Copy Data

**What it does**

- `mov destination, source` copies data from the **source** into the **destination**.
- It does *not* modify the source.
- It is used to move constants (immediate), register values, or memory values into registers or memory.

**Key points / constraints**

- You typically cannot do *memory-to-memory* moves in one instruction (i.e. `mov [mem1], [mem2]` is not allowed). You’d first load from memory into a register, then store from the register to memory.
- The size (byte, word, dword) matters — the assembler infers from registers or you specify with size directives, e.g. `BYTE PTR`, `DWORD PTR` etc. [University of Virginia Computer Science+1](https://www.cs.virginia.edu/~evans/cs216/guides/x86.html)
- Example:
    
    ```nasm
    mov eax, 0x5f       ; move immediate constant 0x5F into register eax
    mov ebx, eax        ; copy value from eax into ebx
    mov eax, [ebx]      ; treat ebx’s content as an address; load from memory into eax
    mov eax, [ebp+4]    ; load from memory at address (ebp + 4) into eax
    
    ```
    

**Why it matters**

- Almost every piece of data transfer in a binary uses `mov` or a variant thereof.
- Recognizing `mov` lets you trace how values are passed between registers and memory.

---

### 2. `lea` — Load Effective Address

**What it does**

- `lea destination, source` computes the *address* (effective memory address) represented by the source operand, and places that address into the destination register.
- It **does not access** memory; it only calculates an address.

**Example**

```nasm
lea eax, [ebp+4]
```

- This computes `ebp + 4` and stores that sum in `eax`.
- If you had used `mov eax, [ebp+4]`, it would instead *load the value stored in memory at address ebp+4* into `eax`.

**Why and when it’s used**

- It’s often used for **pointer arithmetic** or address computations.
- Sometimes compilers use `lea` to do arithmetic (add/sub/multiply) on registers in a single instruction, leveraging the address calculation hardware, even when not actually referencing memory. [Stack Overflow](https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction)
- E.g. in computing array offsets, structure members, or pointer arithmetic, `lea` is elegant and efficient.

---

### 3. `nop` — No Operation

**What it does**

- `nop` literally does nothing. The CPU advances to the next instruction, but no registers, flags, or memory are changed.

**Use cases**

- Padding or alignment: to align code or instructions boundaries.
- **NOP sleds** in malware/shellcode: a run of `nop` instructions ensures that execution “slides” into the payload regardless of precise jump into the sled area.
- Patching / replacing instructions: sometimes one replaces instructions with `nop` to disable functionality (e.g. in patching).
- The opcode for `nop` is `0x90` on x86. [Microsoft Learn+1](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/x86-instructions)

---

### 4. Shift Instructions (`shl`, `shr`) — Bit Shifting

These instructions move bits left or right within a register, filling vacated bits and possibly using flags.

- `shl destination, count` — shift bits in **destination** to the **left** by **count** positions. (Equivalent to multiplying by 2^count)
- `shr destination, count` — shift bits in **destination** to the **right** by **count** positions, discarding low-order bits. (Equivalent to dividing by 2^count, ignoring remainder)

**Details**

- Bits shifted out are lost, and *zeroes* are typically shifted in.
- The **carry flag (CF)** captures the last bit shifted out (for certain operations) so you can use it if needed.
- Example: If `eax = 0000 0010` (in binary) and you do `shl eax, 1`, you get `0000 0100`.
- If `eax = 0000 0101` and you do `shr eax, 1`, result is `0000 0010`, and **CF = 1** (because the least bit was shifted out).
- Shift instructions are often faster than using multiplication or division, so they are used for powers-of-two scaling.

---

### 5. Rotate Instructions (`rol`, `ror`) — Bit Rotation

These are like shifts, but **bits that fall off one end re-enter at the opposite end**.

- `rol destination, count` — rotate bits in **destination** to the **left** by **count** positions
- `ror destination, count` — rotate bits in **destination** to the **right**

**Details**

- Because bits wrap around, the bit-shifted-out end is reinserted at the other side.
- The carry flag (CF) may also be affected (depends on architecture specifics) for the bit that rotates out.
- Example: Suppose an 8-bit register `al` has `1010 1010`.
    - `rol al, 1` → becomes `0101 0101` (the leftmost bit “1” wraps into the rightmost).
    - `ror al, 1` → becomes `0101 0101` as well (effect depends on direction).
- Rotations are useful in bit-level operations, cryptographic or encoding routines, or status manipulations. [Carl Burch+1](https://cburch.com/csbsju/cs/350/handouts/x86.html)

---

## Comparison & Tips

| Instruction | Purpose | Data Moved / Modified | Notes / Use Cases |
| --- | --- | --- | --- |
| `mov` | Copy data | source → destination (register, memory, immediate) | Most basic data transfer |
| `lea` | Compute address | address → register | Arithmetic-on-addresses, pointer arithmetic |
| `nop` | Do nothing | — | Padding, alignment, sleds, patching |
| `shl` / `shr` | Bit shift left / right | modifies bits in destination | Fast multiply/divide by powers of 2 |
| `rol` / `ror` | Bit rotate | wraps bits around | Useful in bit manipulation, crypt/encoding |

---

## Final Thoughts & Why This Is Useful in Malware / Reverse Engineering

- Malware (or any binary) at assembly level is made up of sequences of these instructions (and more). The logic, data flow, and control flow are expressed via `mov`, `lea`, arithmetic/logic, shifts/rotates, and branching instructions.
- Recognizing **how data is moved**, **how addresses are computed**, **how bits are manipulated**, or **where padding/no-ops** are inserted helps you reverse-engineer logic, detect anti-analysis tricks, or understand obfuscated computations.
- For example: a function using a lot of `rol` / `ror` / `xor` / `shl` / `shr` may be implementing encryption, decryption, obfuscation, or hashing routines. [Jai Minton](https://www.jaiminton.com/Tutorials/PracticalMalwareAnalysis/Chapter4/)
- Recognizing `lea` versus `mov` is important — `lea` doesn’t fetch memory, it computes an address, so misuse or misunderstanding can lead to misinterpreting what the code is doing.

# Task-4: Flags

### **Flag Register Bits in x86 Assembly**

| **Flag** | **Abbreviation** | **Explanation** |
| --- | --- | --- |
| **Carry** | **CF** | Set when a carry-out or borrow is required from the most significant bit in an arithmetic operation. Also used for bit-wise shifting operations. |
| **Parity** | **PF** | Set if the least significant byte of the result contains an even number of 1 bits. |
| **Auxiliary** | **AF** | Set if a carry-out or borrow is required from bit 3 to bit 4 in an arithmetic operation (BCD arithmetic). |
| **Zero** | **ZF** | Set if the result of the operation is zero. |
| **Sign** | **SF** | Set if the result of the operation is negative (i.e., the most significant bit is 1). |
| **Overflow** | **OF** | Set if there's a signed arithmetic overflow (e.g., adding two positive numbers and getting a negative result or vice versa). |
| **Direction** | **DF** | Determines the direction for string processing instructions. If DF=0, the string is processed forward; if DF=1, the string is processed backward. |
| **Interrupt Enable** | **IF** | If set (1), it enables maskable hardware interrupts. If cleared (0), interrupts are disabled. |

*Source: tryhackme*

> Flags can be used in conditional jumps and are crucial for implementing conditional branching in assembly code. For example, you might only jump to a specific address if a certain flag is set or cleared.
> 

---

# Task-5: Arithmetic and Logical Instructions

### 🧮 **Arithmetic Instructions**

1. **Addition (`add`)**
    - Adds a value to the destination register and stores the result in the destination.
    - **Example:** `add eax, 5` → `eax = eax + 5`
2. **Subtraction (`sub`)**
    - Subtracts a value from the destination register and stores the result there.
    - **Example:** `sub eax, 1` → `eax = eax - 1`
    - **Flags affected:**
        - **ZF (Zero Flag):** Set if the result is 0.
        - **CF (Carry Flag):** Set if there’s a borrow (destination < value).
3. **Multiplication (`mul`)**
    - Multiplies `eax` by the operand and stores a 64-bit result in `edx:eax`.
        - **eax →** lower 32 bits
        - **edx →** upper 32 bits
    - **Example:** `mul ebx` → `EDX:EAX = EAX * EBX`
4. **Division (`div`)**
    - Divides the 64-bit value in `edx:eax` by the operand.
        - **eax →** quotient
        - **edx →** remainder
    - **Example:** `div ebx` → `EAX = EDX:EAX / EBX`, `EDX = remainder`
5. **Increment (`inc`) / Decrement (`dec`)**
    - `inc eax` → adds 1 to `eax`
    - `dec eax` → subtracts 1 from `eax`

---

### ⚙️ **Logical Instructions**

1. **AND (`and`)**
    - Performs bitwise AND — result bit is `1` only if both bits are `1`.
    - **Example:**
        - `al = 11111100`, `0x7C = 01111100`
        - Result → `01111100`
2. **OR (`or`)**
    - Performs bitwise OR — result bit is `1` if *either* bit is `1`.
    - **Example:**
        - `al = 10001100`, `0x7C = 01111100`
        - Result → `11111100`
3. **NOT (`not`)**
    - Inverts all bits (1 → 0, 0 → 1).
    - **Example:** `al = 11110000` → becomes `00001111`
4. **XOR (`xor`)**
    - Performs bitwise exclusive OR — result bit is `1` only if bits are *different*.
    - **Example:**
        - `al = 11111100`, `0x7C = 01111100` → Result `10000000`
    - **Special use:** `xor eax, eax` sets `eax` to **0** — faster than `mov eax, 0`.

# Task-6: Conditionals and Branching

### **Conditionals**

Conditionals in assembly are used to compare or test values and set specific **flags** in the CPU to indicate the result. These flags (like **ZF** or **CF**) are then used by **conditional jump instructions** to decide the program’s next step.

### **TEST Instruction**

- Performs a **bitwise AND** between two operands.
- Does **not** store the result — it only affects flags.
- **ZF (Zero Flag)** is set if the result is zero.
- Commonly used to check if a register is empty (zero).
    - Example: `test eax, eax` → checks if `eax` = 0.

### **CMP Instruction**

- Compares two operands by performing a **subtraction-like operation** without changing the operands.
- **ZF** = 1 → operands are equal.
- **CF** = 1 → source operand is greater than destination.
- Used before conditional jumps.
    - Example:
        
        ```nasm
        cmp eax, ebx
        je equal_label   ; jump if equal
        ```
        

---

### **Branching**

Branching changes the **control flow** of a program — instead of executing sequentially, the CPU “jumps” to another part of the code.

### **JMP Instruction**

- An **unconditional jump** — always transfers control to the target location.
    - Example: `jmp start_loop`

### **Conditional Jumps**

- These only jump if a **condition** based on flag values is true.
- Equivalent to **if statements** in high-level languages.
- Syntax: `j(condition) label`

---

### **Conditional Jump Instructions**

(`<` less than, `>`greater than)

| Instruction | Meaning | Condition |
| --- | --- | --- |
| **jz** | Jump if zero | ZF = 1 |
| **jnz** | Jump if not zero | ZF = 0 |
| **je** | Jump if equal | ZF = 1 |
| **jne** | Jump if not equal | ZF = 0 |
| **jg** | Jump if greater (signed) | Destination > Source |
| **jl** | Jump if less (signed) | Destination < Source |
| **jge** | Jump if greater or equal (signed) | Dest ≥ Source |
| **jle** | Jump if less or equal (signed) | Dest ≤ Source |
| **ja** | Jump if above (unsigned) | Dest > Source |
| **jb** | Jump if below (unsigned) | Dest < Source |
| **jae** | Jump if above or equal (unsigned) | Dest ≥ Source |
| **jbe** | Jump if below or equal (unsigned) | Dest ≤ Source |

<img width="1536" height="1024" alt="image" src="https://github.com/user-attachments/assets/54ac3039-491c-4eb7-88b6-615649ad68c2" />

### Example to Tie It All Together

```nasm
cmp eax, ebx    ; compare two values
jg greater_val  ; if eax > ebx → jump to greater_val
je equal_val    ; if eax == ebx → jump to equal_val
jmp end         ; else → jump to end
```

This example mimics:

```c
if (eax > ebx) { ... }
else if (eax == ebx) { ... }
else { ... }
```

# Task-7: The stack

### **The Stack**

The **stack** is a special region of memory that works on a **Last In, First Out (LIFO)** principle — meaning the *last* item pushed onto the stack is the *first* one removed.

In x86 systems, the **stack** is mainly used to:

- Store temporary data (like local variables)
- Save register values
- Manage **function calls** (store return addresses and parameters)

The **ESP (Stack Pointer)** register always points to the **top** of the stack, and **EBP (Base Pointer)** is used to reference local variables or parameters within a function.

The stack grows **downward** in memory — meaning each new push *decreases* the address in ESP.

---

### **PUSH Instruction**

**Syntax:**

```
push source
```

- The `push` instruction **saves (pushes)** a value onto the stack.
- It **decrements ESP** (moves it downward) by 4 bytes (for 32-bit) or 8 bytes (for 64-bit), then **stores** the operand’s value at that address.
- This operation is useful for saving register values or arguments before a function call.

**Variants:**

- `pusha`: pushes all 16-bit general-purpose registers (AX, BX, CX, DX, SI, DI, SP, BP).
- `pushad`: pushes all 32-bit general-purpose registers (EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP).

💡 These are often seen in **shellcode or low-level routines** to preserve the CPU state before executing new instructions.

---

### **POP Instruction**

**Syntax:**

```
pop destination
```

- The `pop` instruction **retrieves (pops)** the topmost value from the stack and stores it into the destination (register or memory).
- It **increments ESP**, effectively removing that value from the stack.

**Variants:**

- `popa`: pops all 16-bit general-purpose registers in the order — DI, SI, BP, BX, DX, CX, AX.
- `popad`: pops all 32-bit general-purpose registers — EDI, ESI, EBP, EBX, EDX, ECX, EAX.

💡 Commonly used to **restore** register values after a function call or interrupt.

---

### **CALL Instruction**

**Syntax:**

```
call location
```

The `call` instruction is used to **invoke a function**.

Here’s what happens step-by-step when a `call` executes:

1. The **address of the next instruction** (the return address) is **pushed onto the stack**.
2. The **Instruction Pointer (EIP)** jumps to the address specified by `location`, beginning execution of the function code.

Inside a function, there is often a **prologue** and **epilogue**:

- **Function Prologue:**
    - Saves the previous base pointer (`push ebp`).
    - Sets a new stack frame (`mov ebp, esp`).
    - Allocates local variables (`sub esp, <size>`).
- **Function Epilogue:**
    - Restores the old stack frame (`mov esp, ebp`).
    - Restores old base pointer (`pop ebp`).
    - Returns control back using `ret`, which pops the return address back into EIP.

**Calling conventions** (like `cdecl`, `stdcall`, `fastcall`) determine how arguments are passed — either **on the stack** or **in registers**, and who (caller or callee) cleans up the stack.

---

### **In Summary**

| Concept | Description |
| --- | --- |
| **Stack** | LIFO memory structure used for temporary data, function parameters, and return addresses. |
| **ESP (Stack Pointer)** | Points to the top of the stack (changes with push/pop). |
| **EBP (Base Pointer)** | Used as a fixed reference point within the current stack frame. |
| **PUSH** | Saves data to the stack (ESP decreases). |
| **POP** | Restores data from the stack (ESP increases). |
| **CALL** | Pushes the return address and jumps to a function. |
| **RET** | Pops the return address and returns control. |

# **Task 8: Practice Time — Learning by Doing**

This task is a **hands-on exercise** using an **Assembly Emulator** to visualize how different x86 assembly instructions affect the **CPU registers**, **memory**, **flags**, and **stack**.

The emulator provides control options to:

- ▶️ **Run the program**
- ⏭️ **Execute the next instruction**
- ⏹️ **Stop execution**
- 🔁 **Restart the program**

Visit the site [here](https://static-labs.tryhackme.cloud/sites/assembly-emulator/)

Each section below focuses on a different type of instruction:

---

### ⚙️ **1. Arithmetic Instructions**

**Purpose:** To show how arithmetic operations modify registers and flags.

**Code Example:**

```nasm
mov eax,20h ; eax = 0x20 (32)
mov ebx,30h ; ebx = 0x30 (48)
add eax,ebx ; eax = 0x20 + 0x30 = 0x50 (80 decimal)
nop
nop
sub eax,ebx ; eax = 0x50 - 0x30 = 0x20
inc ebx     ; ebx = 0x30 + 1 = 0x31
dec ebx     ; ebx = 0x31 - 1 = 0x30
mul eax     ; EDX:EAX = EAX * EAX
```

**Explanation:**

- `mov` sets up initial values in registers.
- `add` and `sub` modify `EAX` based on `EBX`.
- `inc` and `dec` increase/decrease a register by 1.
- `mul` performs unsigned multiplication (`EAX` × source).
    
    You can observe how the **Zero Flag (ZF)**, **Carry Flag (CF)**, and **Overflow Flag (OF)** change based on results.
    

```nasm
mov eax,20h ; EAX = 0x20 (decimal 32)
```

<img width="1743" height="764" alt="image" src="https://github.com/user-attachments/assets/336d8bab-dde1-4c4b-9cea-9e3a62d13102" />

The **EIP register** (in 32-bit x86 CPUs) stands for **Extended Instruction Pointer,** and it always points to the next instruction 

```nasm
mov ebx,30h ; EBX = 0x30 (decimal 48)
```

<img width="1664" height="688" alt="image" src="https://github.com/user-attachments/assets/5ce9007e-4780-4358-874d-5ecb3d405bc6" />

**Third instruction**, it will add ebx to eax and save the result to eax. (EAX = 0x20 + 0x30 = 0x50) and the parity flag will be set because the 0x50 = 0101 0000 (binary) has an even number of 1’s 

```nasm
add eax,ebx ; EAX = 0x20 + 0x30 = 0x50
```

<img width="957" height="781" alt="image" src="https://github.com/user-attachments/assets/74b723e0-efaf-4ed9-87df-40a783b93455" />

Here, the nop instruction didn't make any changes; only the EIP was incremented 

```nasm
nop 
```

<img width="926" height="744" alt="image" src="https://github.com/user-attachments/assets/be342feb-45ca-495a-8b1e-e728219911e1" />

Now for the subtraction, the result will be 0x20 (in binary= 0010 0000), and the Parity flag will not be set since the binary equivalent is odd

```nasm
sub eax,ebx ; EAX = 0x30 - 0x50 = 0x20
```

<img width="935" height="746" alt="image" src="https://github.com/user-attachments/assets/e4aa468a-81e6-44ab-8a07-601678a20003" />

7th instruction: Increment EBX by one, the result will be (0x31)

```nasm
inc ebx
```

<img width="913" height="713" alt="image" src="https://github.com/user-attachments/assets/335a20dd-343e-4ff9-bff1-ca94f75d5ade" />

8th Instruction: decrement by one; this will return the EBX to `0x30` (0011 0000).

```nasm
dec ebx
```

<img width="857" height="704" alt="image" src="https://github.com/user-attachments/assets/c37aaa4d-c684-4333-8836-cdb1204faee0" />

8th instruction: 

- Current `eax = 0x20` → 32 decimal
- Multiplication: `32 * 32 = 1024 decimal = 0x400`

```nasm
mul eax ; EDX:EAX = EAX * EAX
```

<img width="827" height="696" alt="image" src="https://github.com/user-attachments/assets/178bcd04-c945-41a2-a424-232621d0842f" />

---

### **2. MOV Instructions**

**Purpose:** To understand data transfer between registers and memory.

**Code Example:**

```nasm
mov eax,10h 
mov ebx,32h
mov ecx,eax
mov [eax],40h
add [eax],30h
mov [ebx],[eax] ; test if direct memory-to-memory move is allowed
```

**Key Points:**

- `mov` copies data between registers or between registers and memory.
- Direct **memory-to-memory** moves (like `mov [ebx],[eax]`) are **not allowed** in x86; you must move data through a register first.
- Observe how writing to `[eax]` updates memory at that address.

First instruction: Puts **0x10 (16 decimal)** into the **EAX register**.

<img width="1656" height="709" alt="image" src="https://github.com/user-attachments/assets/cf86f3fb-eca4-4066-a1c6-570a7946fa18" />

Second instruction: Puts 0x32 (50 decimal) into the EBX 

<img width="1643" height="735" alt="image" src="https://github.com/user-attachments/assets/4ffcb827-8613-425d-991b-a84d08f5a6df" />

Third Instruction: Copies the value from **EAX (0x10)** into **ECX**.

<img width="1501" height="709" alt="image" src="https://github.com/user-attachments/assets/2a0a614e-bae6-41d8-8023-789b4ff4489f" />

Fourth Instruction: 

- `[eax]` means **memory at address stored in EAX**.
- EAX = 0x10 → memory address 0x10
- This writes **0x40 (64 decimal)** to **memory at 0x10**.

<img width="1775" height="760" alt="image" src="https://github.com/user-attachments/assets/ed355d5d-7773-41a3-a56e-01980977bbd4" />

Fifth Instruction: 

- Adds **0x30 (48 decimal)** to the **value in memory at address EAX**.
- Memory at 0x10 currently = 0x40 → add 0x30 → 0x70. (**Look at the Hex column**)
- This is **memory-to-memory arithmetic**, but note: in x86, **`add` supports memory as one operand, not both**. Here `[eax]` is the **destination**; 0x30 is an **immediate**. ✅ Allowed.

<img width="1661" height="742" alt="image" src="https://github.com/user-attachments/assets/e1f3e53a-2b19-4e3f-a915-3649c4373e5a" />

Now for the last instruction:

<img width="1505" height="681" alt="image" src="https://github.com/user-attachments/assets/3b342b60-50d8-49b0-afab-75447778bb72" />

- **Memory-to-memory moves are NOT allowed in x86**!
- x86 only allows **one operand to be memory**:
    - Allowed: `mov reg, [mem]` or `mov [mem], reg`
    - Not allowed: `mov [mem], [mem]` → this will cause **assembly error**
- To achieve memory-to-memory copy, you must use a **register as intermediate**
    
    ```nasm
    mov eax, [eax]   ; load from source memory
    mov [ebx], eax   ; store to destination memory
    ```
    

---

### **3. Stack Operations**

**Purpose:** To visualize how the **stack** works (LIFO — Last In, First Out).

**Code Example:**

```nasm
mov eax,10h
mov ebx,15h
mov ecx,20h
mov edx,25h
push eax
push ebx
push ecx
push edx
pop eax
pop ebx
pop ecx
pop edx
```

**Explanation:**

- **Push** adds a value to the top of the stack (stack pointer decreases).
- **Pop** removes the most recently pushed value (stack pointer increases).
- The stack grows **downward** in memory, from high to low addresses.
- Order of retrieval shows **LIFO behavior** — the last pushed value is the first popped out.

Starting from the Push command: Push 0x10 to the stack

- The ESP: stack pointer → Always points to the **top of the stack,** which is currently pointed to 0XFFC (0x10)
- EIP: Instruction Pointer(in 32-bit) → stores the memory address of the next instruction to be executed by the CPU and the next instruction is set to 5

<img width="1664" height="659" alt="image" src="https://github.com/user-attachments/assets/5ff636ed-1e2f-4075-86e1-2b406bbbfc5a" />

We pushed the rest of the values to the stack and noted that the **ESP** now points to the last entered value (0xFF0)

<img width="1676" height="739" alt="image" src="https://github.com/user-attachments/assets/a04ca85d-287a-465c-9f36-a53ea3125991" />

Now for the POP operation: 

- `POP destination`
- `pop` **reads the value from the top of the stack** and **writes it into the register**.
- **Important:** Whatever value was in EAX **before the pop is overwritten** by the value popped from the stack.
- Before pop (EAX = 0x10), after pop (EAX=0x25)
- ESP decremented.

<img width="1696" height="712" alt="image" src="https://github.com/user-attachments/assets/761b1cdd-cbe2-4556-9527-8213e4def98b" />

<img width="1705" height="778" alt="image" src="https://github.com/user-attachments/assets/7af01308-0a7a-4505-aab5-f6144bab702d" />

---

### **4. CMP and TEST Instructions**

**Purpose:** To examine how comparison and bit testing affect **flags**.

**Code Example:**

```nasm
mov eax,10h
mov ebx,10h
cmp eax,ebx
test eax,ebx
mov eax,20h
mov ebx,10h
cmp eax,ebx
test eax,ebx
mov eax,20h
mov ebx,40h
cmp eax,ebx
test eax,ebx
```

**Explanation:**

- `cmp` subtracts the source from the destination but doesn’t store the result — it just sets flags.
- `test` performs a **bitwise AND**, setting flags based on the result (often used to check if a value is zero).
- When:
    - `EAX == EBX` → **ZF = 1**
    - `EAX > EBX` → **ZF = 0, CF = 0**
    - `EAX < EBX` → **ZF = 0, CF = 1**

These flags determine conditional jumps like `JE` (jump if equal) or `JL` (jump if less).

| **Condition** | **Example** | **Flags affected by cmp instruction** | **Flags affected by test instruction** |
| --- | --- | --- | --- |
| When both values are equal | eax = ebx | Parity Flag, Zero Flag | No flag is impacted |
| When eax is greater than ebx | eax > ebx | No flag is impacted | Parity Flag, Zero Flag |
| When eax is less than ebx | eax < ebx | Carry Flag, Sign Flag | Parity Flag, Zero Flag |

CMP-1 compare operation: 

- Performs → 0x10 - 0x10 = 0
- The result is zero, so the **Zero Flag** is set
- So EAX == EBX

<img width="980" height="701" alt="image" src="https://github.com/user-attachments/assets/7d6caed2-3191-4fe6-8b53-5aef2c9ca00c" />

TEST-1 operation: 

- Performs `0x10 AND 0x10 = 0x10` (non-zero)

<img width="862" height="720" alt="image" src="https://github.com/user-attachments/assets/8faaa54b-a1a1-4d37-82ff-e47acb2b7ed3" />

**CMP-2 operation:** 

- MOV operation: **Note here**, the move operation overwrites the value previously stored in the registry. From 10 to 20

Now compare the new value with 10 

- Compare  EAX - EBX → 0x20 - 0x10 = 0x10
- Result ≠ 0, ZF =0

<img width="959" height="714" alt="image" src="https://github.com/user-attachments/assets/9ce5a763-c406-4a58-8e28-c159262b2815" />

Test-2 operation:

- EAX AND EBX =  0010 0000  (0x20) AND 0001 0000 (0x10) = 0000 0000
- All zero so Zero Flag is set
- PF = 1 (even number of 1s — zero result counts as even)

<img width="874" height="663" alt="image" src="https://github.com/user-attachments/assets/b2cfe075-2696-471c-8821-344e1dddadaf" />

CMP-3 operation:

- with the new values: 0x20 - 0x40 = -0x20
- Sign Flag =1 (Negitave)
- Carry Flag = 1 (borrow occurred)

<img width="918" height="752" alt="image" src="https://github.com/user-attachments/assets/fa80cd86-9e31-4c02-918a-bdc41e64337b" />

Test-3 Operation: 

- EAX AND EBX → 0010 0000 (0x20) `AND` 0100 0000 (0x40) = 0000 0000
- All zero, ZF=1
- Even zeros, Parity=1

<img width="854" height="729" alt="image" src="https://github.com/user-attachments/assets/c520acb9-fcae-4903-8ab7-4a2c670ff435" />

---

### **5. LEA (Load Effective Address) Instruction**

**Purpose:** To understand how memory addresses are computed and stored.

**Code Example:**

```nasm
mov eax,20h
mov ebx,30h
add eax,ebx ; EAX = 0x20 + 0x30 = 0x50 (80)
mov [eax],ebx ;writes the value in EBX (0x30) into memory address 0x50,Memory[0x50] =0x30
add ebx,15h ; EBX = 0x30 + 0x15 = 0x45
mov ecx,6
mov [ebx+ecx],eax
lea eax,[ebx+ecx]
push eax
push ebx
pop ecx
```

**Explanation:**

- `lea` (Load Effective Address) loads the *address* of an operand, not its value.
    
    Example: `lea eax,[ebx+ecx]` → stores the computed address (EBX + ECX) in `EAX`.
    
- Often used for pointer arithmetic or optimizing address calculations.
- Pushing and popping show how function calls and returns manage data using the stack.

`mov [ebx+ecx],eax`

- EBX = 0x45
- ECX = 0x6
- EAX = 0x50

Effective address = EBX + ECX = 0x45 + 0x6 = **0x4B, so the instruction says:** 

- Move the contents of **EAX (0x50)** into **memory address [0x4B]**.

<img width="1496" height="748" alt="image" src="https://github.com/user-attachments/assets/2d93b8f1-2538-4481-9890-c9b0ee978b2f" />

`LEA dest, src`

- `LEA` (Load Effective Address) doesn’t read memory — it just **computes the address** and stores it into a register.
- So, `EAX = EBX + ECX = 0x45 + 0x6 = 0x4B`
- EAX = 0x4B

⚠️ Important: `lea` is purely arithmetic — it doesn’t access the memory at 0x4B.

<img width="1414" height="711" alt="image" src="https://github.com/user-attachments/assets/be3569e0-2fb9-4768-b170-2b0ba52d601b" />

---

# **Task 9 : Conclusion**

In this room, we covered some of the most commonly used instructions in x86 assembly language. Though there are many other instructions, we covered the ones that briefly overview how operations are performed in the assembly language. As we move forward to other rooms in this module, we will learn about some more instructions as per requirements. In this room, we have covered the following:

- Opcodes and how we convert them into the assembly language.
- General instructions such as move, load effective address, shift and rotate.
- Arithmetic instructions such as addition, subtraction, multiplication, and division.
- Conditionals and how we use them for branching.
- Stack, the push and pop instructions, and function calls.
